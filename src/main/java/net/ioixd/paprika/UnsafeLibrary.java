
/*
    This file is generated by a Python script. Do not make direct modifications to it.
    Please modify the script that generates it instead.
*/
package net.ioixd.paprika;
import javax.annotation.Nullable;
import org.jetbrains.annotations.NotNull;

import org.bukkit.*;
import org.bukkit.entity.*;
import org.bukkit.configuration.serialization.*;
import org.bukkit.metadata.*;
import org.bukkit.persistence.*;
import org.bukkit.plugin.messaging.*;
import org.bukkit.permissions.*;
import org.bukkit.generator.*;

public class UnsafeLibrary {

        org.bukkit.entity.AnimalTamer constructAnimalTamer(String json) {
            AnimalTamer obj = new AnimalTamer() {
            
				@Nullable
                public String getName() {
        			return name;
			}
                public String name;
        
				@NotNull
                public UUID getUniqueId() {
        			return uniqueId;
			}
                public UUID uniqueId;
        
            };
            return obj;
        }
    
        org.bukkit.OfflinePlayer constructOfflinePlayer(String json) {
            OfflinePlayer obj = new OfflinePlayer() {
            
                public void decrementStatistic(Statistic statistic) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, int amount) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, EntityType entityType) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, EntityType entityType, int amount) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, Material material) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, Material material, int amount) {
        			/* TODO */
				}
				@Nullable
                public Location getBedSpawnLocation() {
        			return bedSpawnLocation;
			}
                public Location bedSpawnLocation;
        
                public long getFirstPlayed() {
        			return firstPlayed;
			}
                public long firstPlayed;
        
				@Nullable
                public Location getLastDeathLocation() {
        			return lastDeathLocation;
			}
                public Location lastDeathLocation;
        
                public long getLastPlayed() {
        			return lastPlayed;
			}
                public long lastPlayed;
        
				@Nullable
                public String getName() {
        			return name;
			}
                public String name;
        
				@Nullable
                public Player getPlayer() {
        			return player;
			}
                public Player player;
        
				@NotNull
                public PlayerProfile getPlayerProfile() {
        			return playerProfile;
			}
                public PlayerProfile playerProfile;
        
                public int getStatistic(Statistic statistic) {
        			/* TODO */
				}
                public int getStatistic(Statistic statistic, EntityType entityType) {
        			/* TODO */
				}
                public int getStatistic(Statistic statistic, Material material) {
        			/* TODO */
				}
				@NotNull
                public UUID getUniqueId() {
        			return uniqueId;
			}
                public UUID uniqueId;
        
                public boolean hasPlayedBefore() {
        			return playedBefore;
			}
                public boolean playedBefore;
        
                public void incrementStatistic(Statistic statistic) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, int amount) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, EntityType entityType) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, Material material) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, Material material, int amount) {
        			/* TODO */
				}
                public boolean isBanned() {
        			return banned;
			}
                public boolean banned;
        
                public boolean isOnline() {
        			return online;
			}
                public boolean online;
        
                public boolean isWhitelisted() {
        			return whitelisted;
			}
                public boolean whitelisted;
        
                public void setStatistic(Statistic statistic, int newValue) {
        			/* TODO */
				}
                public void setStatistic(Statistic statistic, EntityType entityType, int newValue) {
        			/* TODO */
				}
                public void setStatistic(Statistic statistic, Material material, int newValue) {
        			/* TODO */
				}
                public void setWhitelisted(boolean value) {
        			whitelisted = value;
                }
                
				@NotNull
                public Map<String,Object> serialize() {
        			/* TODO */
				}
                public boolean isOp() {
        			return op;
			}
                public boolean op;
        
                public void setOp(boolean value) {
        			op = value;
                }
                
            };
            return obj;
        }
    
        org.bukkit.BanEntry constructBanEntry(String json) {
            BanEntry obj = new BanEntry() {
            
				@NotNull
                public Date getCreated() {
        			return created;
			}
                public Date created;
        
				@Nullable
                public Date getExpiration() {
        			return expiration;
			}
                public Date expiration;
        
				@Nullable
                public String getReason() {
        			return reason;
			}
                public String reason;
        
				@NotNull
                public String getSource() {
        			return source;
			}
                public String source;
        
				@NotNull
                public String getTarget() {
        			return target;
			}
                public String target;
        
                public void save() {
        			/* TODO */
				}
                public void setCreated(Date created) {
        			created = created;
                }
                
                public void setExpiration(Date expiration) {
        			expiration = expiration;
                }
                
                public void setReason(String reason) {
        			reason = reason;
                }
                
                public void setSource(String source) {
        			source = source;
                }
                
            };
            return obj;
        }
    
        org.bukkit.BanList constructBanList(String json) {
            BanList obj = new BanList() {
            
				@Nullable
                public BanEntry addBan(String target, String reason, Date expires, String source) {
        			/* TODO */
				}
				@NotNull
                public Set<BanEntry> getBanEntries() {
        			return banEntries;
			}
                public Set<BanEntry> banEntries;
        
				@Nullable
                public BanEntry getBanEntry(String target) {
        			/* TODO */
				}
                public boolean isBanned(String target) {
        			/* TODO */
				}
                public void pardon(String target) {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.BlockChangeDelegate constructBlockChangeDelegate(String json) {
            BlockChangeDelegate obj = new BlockChangeDelegate() {
            
				@NotNull
                public BlockData getBlockData(int x, int y, int z) {
        			/* TODO */
				}
                public int getHeight() {
        			return height;
			}
                public int height;
        
                public boolean isEmpty(int x, int y, int z) {
        			/* TODO */
				}
                public boolean setBlockData(int x, int y, int z, BlockData blockData) {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.ChunkSnapshot constructChunkSnapshot(String json) {
            ChunkSnapshot obj = new ChunkSnapshot() {
            
                public boolean contains(BlockData block) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(int x, int y, int z) {
        			/* TODO */
				}
                public int getBlockEmittedLight(int x, int y, int z) {
        			/* TODO */
				}
                public int getBlockSkyLight(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Material getBlockType(int x, int y, int z) {
        			/* TODO */
				}
                public long getCaptureFullTime() {
        			return captureFullTime;
			}
                public long captureFullTime;
        
                public int getData(int x, int y, int z) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z) {
        			/* TODO */
				}
                public double getRawBiomeTemperature(int x, int z) {
        			/* TODO */
				}
                public double getRawBiomeTemperature(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public String getWorldName() {
        			return worldName;
			}
                public String worldName;
        
                public int getX() {
        			return x;
			}
                public int x;
        
                public int getZ() {
        			return z;
			}
                public int z;
        
                public boolean isSectionEmpty(int sy) {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.configuration.serialization.ConfigurationSerializable constructConfigurationSerializable(String json) {
            ConfigurationSerializable obj = new ConfigurationSerializable() {
            
				@NotNull
                public Map<String,Object> serialize() {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.OfflinePlayer constructOfflinePlayer(String json) {
            OfflinePlayer obj = new OfflinePlayer() {
            
                public void decrementStatistic(Statistic statistic) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, int amount) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, EntityType entityType) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, EntityType entityType, int amount) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, Material material) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, Material material, int amount) {
        			/* TODO */
				}
				@Nullable
                public Location getBedSpawnLocation() {
        			return bedSpawnLocation;
			}
                public Location bedSpawnLocation;
        
                public long getFirstPlayed() {
        			return firstPlayed;
			}
                public long firstPlayed;
        
				@Nullable
                public Location getLastDeathLocation() {
        			return lastDeathLocation;
			}
                public Location lastDeathLocation;
        
                public long getLastPlayed() {
        			return lastPlayed;
			}
                public long lastPlayed;
        
				@Nullable
                public String getName() {
        			return name;
			}
                public String name;
        
				@Nullable
                public Player getPlayer() {
        			return player;
			}
                public Player player;
        
				@NotNull
                public PlayerProfile getPlayerProfile() {
        			return playerProfile;
			}
                public PlayerProfile playerProfile;
        
                public int getStatistic(Statistic statistic) {
        			/* TODO */
				}
                public int getStatistic(Statistic statistic, EntityType entityType) {
        			/* TODO */
				}
                public int getStatistic(Statistic statistic, Material material) {
        			/* TODO */
				}
				@NotNull
                public UUID getUniqueId() {
        			return uniqueId;
			}
                public UUID uniqueId;
        
                public boolean hasPlayedBefore() {
        			return playedBefore;
			}
                public boolean playedBefore;
        
                public void incrementStatistic(Statistic statistic) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, int amount) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, EntityType entityType) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, Material material) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, Material material, int amount) {
        			/* TODO */
				}
                public boolean isBanned() {
        			return banned;
			}
                public boolean banned;
        
                public boolean isOnline() {
        			return online;
			}
                public boolean online;
        
                public boolean isWhitelisted() {
        			return whitelisted;
			}
                public boolean whitelisted;
        
                public void setStatistic(Statistic statistic, int newValue) {
        			/* TODO */
				}
                public void setStatistic(Statistic statistic, EntityType entityType, int newValue) {
        			/* TODO */
				}
                public void setStatistic(Statistic statistic, Material material, int newValue) {
        			/* TODO */
				}
                public void setWhitelisted(boolean value) {
        			whitelisted = value;
                }
                
				@NotNull
                public Map<String,Object> serialize() {
        			/* TODO */
				}
                public boolean isOp() {
        			return op;
			}
                public boolean op;
        
                public void setOp(boolean value) {
        			op = value;
                }
                
            };
            return obj;
        }
    
        org.bukkit.Registry constructRegistry(String json) {
            Registry obj = new Registry() {
            
				@Nullable
                public T get(NamespacedKey key) {
        
            };
            return obj;
        }
    
        org.bukkit.Keyed constructKeyed(String json) {
            Keyed obj = new Keyed() {
            
				@NotNull
                public NamespacedKey getKey() {
        			return key;
			}
                public NamespacedKey key;
        
            };
            return obj;
        }
    
        org.bukkit.Tag constructTag(String json) {
            Tag obj = new Tag() {
            
				@NotNull
                public Set<T> getValues() {
        			return values;
			}
                public Set<T> values;
        
                public boolean isTagged(T item) {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.World constructWorld(String json) {
            World obj = new World() {
            
                public boolean addPluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public boolean canGenerateStructures() {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
                public boolean generateTree(Location location, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
        			/* TODO */
				}
                public boolean getAllowAnimals() {
        			return allowAnimals;
			}
                public boolean allowAnimals;
        
                public boolean getAllowMonsters() {
        			return allowMonsters;
			}
                public boolean allowMonsters;
        
                public int getAmbientSpawnLimit() {
        			return ambientSpawnLimit;
			}
                public int ambientSpawnLimit;
        
                public int getAnimalSpawnLimit() {
        			return animalSpawnLimit;
			}
                public int animalSpawnLimit;
        
				@NotNull
                public Biome getBiome(int x, int z) {
        			/* TODO */
				}
				@Nullable
                public BiomeProvider getBiomeProvider() {
        			return biomeProvider;
			}
                public BiomeProvider biomeProvider;
        
				@NotNull
                public Block getBlockAt(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Block block) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Location location) {
        			/* TODO */
				}
                public int getClearWeatherDuration() {
        			return clearWeatherDuration;
			}
                public int clearWeatherDuration;
        
				@NotNull
                public Difficulty getDifficulty() {
        			return difficulty;
			}
                public Difficulty difficulty;
        
				@NotNull
                public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTemp) {
        			/* TODO */
				}
				@Nullable
                public DragonBattle getEnderDragonBattle() {
        			return enderDragonBattle;
			}
                public DragonBattle enderDragonBattle;
        
				@NotNull
                public List<Entity> getEntities() {
        			return entities;
			}
                public List<Entity> entities;
        
				@NotNull
                <T extends getEntitiesByClass(Class<T> cls) {
        			/* TODO */
				}
				@NotNull
                <T extends getEntitiesByClass(Class<T>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Chunk> getForceLoadedChunks() {
        			return forceLoadedChunks;
			}
                public Collection<Chunk> forceLoadedChunks;
        
                public long getFullTime() {
        			return fullTime;
			}
                public long fullTime;
        
				@Nullable
                public <T> T getGameRuleDefault(GameRule<T> rule) {
        			/* TODO */
				}
				@NotNull
                public String[] getGameRules() {
        			return gameRules;
			}
                public String[] gameRules;
        
				@Nullable
                public String getGameRuleValue(String rule) {
        			/* TODO */
				}
				@Nullable
                public <T> T getGameRuleValue(GameRule<T> rule) {
        			/* TODO */
				}
                public long getGameTime() {
        			return gameTime;
			}
                public long gameTime;
        
				@Nullable
                public ChunkGenerator getGenerator() {
        			return generator;
			}
                public ChunkGenerator generator;
        
				@NotNull
                public Block getHighestBlockAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public double getHumidity(int x, int z) {
        			/* TODO */
				}
                public double getHumidity(int x, int y, int z) {
        			/* TODO */
				}
                public boolean getKeepSpawnInMemory() {
        			return keepSpawnInMemory;
			}
                public boolean keepSpawnInMemory;
        
				@NotNull
                public List<LivingEntity> getLivingEntities() {
        			return livingEntities;
			}
                public List<LivingEntity> livingEntities;
        
				@NotNull
                public Chunk[] getLoadedChunks() {
        			return loadedChunks;
			}
                public Chunk[] loadedChunks;
        
                public int getLogicalHeight() {
        			return logicalHeight;
			}
                public int logicalHeight;
        
                public int getMonsterSpawnLimit() {
        			return monsterSpawnLimit;
			}
                public int monsterSpawnLimit;
        
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public List<Player> getPlayers() {
        			return players;
			}
                public List<Player> players;
        
				@NotNull
                public Map<Plugin,Collection<Chunk>> getPluginChunkTickets() {
        			return pluginChunkTickets;
			}
                public Map<Plugin,Collection<Chunk>> pluginChunkTickets;
        
				@NotNull
                public Collection<Plugin> getPluginChunkTickets(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public List<BlockPopulator> getPopulators() {
        			return populators;
			}
                public List<BlockPopulator> populators;
        
                public boolean getPVP() {
        			return pVP;
			}
                public boolean pVP;
        
				@NotNull
                public List<Raid> getRaids() {
        			return raids;
			}
                public List<Raid> raids;
        
                public int getSeaLevel() {
        			return seaLevel;
			}
                public int seaLevel;
        
                public int getSimulationDistance() {
        			return simulationDistance;
			}
                public int simulationDistance;
        
                public int getSpawnLimit(SpawnCategory spawnCategory) {
        			/* TODO */
				}
				@NotNull
                public Location getSpawnLocation() {
        			return spawnLocation;
			}
                public Location spawnLocation;
        
                public double getTemperature(int x, int z) {
        			/* TODO */
				}
                public double getTemperature(int x, int y, int z) {
        			/* TODO */
				}
                public int getThunderDuration() {
        			return thunderDuration;
			}
                public int thunderDuration;
        
                public long getTicksPerAmbientSpawns() {
        			return ticksPerAmbientSpawns;
			}
                public long ticksPerAmbientSpawns;
        
                public long getTicksPerAnimalSpawns() {
        			return ticksPerAnimalSpawns;
			}
                public long ticksPerAnimalSpawns;
        
                public long getTicksPerMonsterSpawns() {
        			return ticksPerMonsterSpawns;
			}
                public long ticksPerMonsterSpawns;
        
                public long getTicksPerSpawns(SpawnCategory spawnCategory) {
        			/* TODO */
				}
                public long getTicksPerWaterAmbientSpawns() {
        			return ticksPerWaterAmbientSpawns;
			}
                public long ticksPerWaterAmbientSpawns;
        
                public long getTicksPerWaterSpawns() {
        			return ticksPerWaterSpawns;
			}
                public long ticksPerWaterSpawns;
        
                public long getTicksPerWaterUndergroundCreatureSpawns() {
        			return ticksPerWaterUndergroundCreatureSpawns;
			}
                public long ticksPerWaterUndergroundCreatureSpawns;
        
                public long getTime() {
        			return time;
			}
                public long time;
        
                public int getViewDistance() {
        			return viewDistance;
			}
                public int viewDistance;
        
                public int getWaterAmbientSpawnLimit() {
        			return waterAmbientSpawnLimit;
			}
                public int waterAmbientSpawnLimit;
        
                public int getWaterAnimalSpawnLimit() {
        			return waterAnimalSpawnLimit;
			}
                public int waterAnimalSpawnLimit;
        
                public int getWaterUndergroundCreatureSpawnLimit() {
        			return waterUndergroundCreatureSpawnLimit;
			}
                public int waterUndergroundCreatureSpawnLimit;
        
                public int getWeatherDuration() {
        			return weatherDuration;
			}
                public int weatherDuration;
        
				@NotNull
                public WorldBorder getWorldBorder() {
        			return worldBorder;
			}
                public WorldBorder worldBorder;
        
				@NotNull
                public File getWorldFolder() {
        			return worldFolder;
			}
                public File worldFolder;
        
				@Nullable
                public WorldType getWorldType() {
        			return worldType;
			}
                public WorldType worldType;
        
                public boolean hasCeiling() {
        			return ceiling;
			}
                public boolean ceiling;
        
                public boolean hasRaids() {
        			return raids;
			}
                public boolean hasSkyLight() {
        			return skyLight;
			}
                public boolean skyLight;
        
                public boolean hasStorm() {
        			return storm;
			}
                public boolean storm;
        
                public boolean isAutoSave() {
        			return autoSave;
			}
                public boolean autoSave;
        
                public boolean isBedWorks() {
        			return bedWorks;
			}
                public boolean bedWorks;
        
                public boolean isChunkForceLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkGenerated(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkInUse(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(Chunk chunk) {
        			/* TODO */
				}
                public boolean isClearWeather() {
        			return clearWeather;
			}
                public boolean clearWeather;
        
                public boolean isGameRule(String rule) {
        			/* TODO */
				}
                public boolean isHardcore() {
        			return hardcore;
			}
                public boolean hardcore;
        
                public boolean isNatural() {
        			return natural;
			}
                public boolean natural;
        
                public boolean isPiglinSafe() {
        			return piglinSafe;
			}
                public boolean piglinSafe;
        
                public boolean isRespawnAnchorWorks() {
        			return respawnAnchorWorks;
			}
                public boolean respawnAnchorWorks;
        
                public boolean isThundering() {
        			return thundering;
			}
                public boolean thundering;
        
                public boolean isUltraWarm() {
        			return ultraWarm;
			}
                public boolean ultraWarm;
        
                public void loadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean loadChunk(int x, int z, boolean generate) {
        			/* TODO */
				}
                public void loadChunk(Chunk chunk) {
        			/* TODO */
				}
				@Nullable
                public Raid locateNearestRaid(Location location, int radius) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, Structure structure, int radius, boolean findUnexplored) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, StructureType structureType, int radius, boolean findUnexplored) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data, int radius) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data, int radius) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, Predicate<Entity> filter) {
        			/* TODO */
				}
                public boolean refreshChunk(int x, int z) {
        			/* TODO */
				}
                public boolean regenerateChunk(int x, int z) {
        			/* TODO */
				}
                public boolean removePluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public void removePluginChunkTickets(Plugin plugin) {
        			/* TODO */
				}
                public void save() {
        			/* TODO */
				}
                public void setAmbientSpawnLimit(int limit) {
        			ambientSpawnLimit = limit;
                }
                
                public void setAnimalSpawnLimit(int limit) {
        			animalSpawnLimit = limit;
                }
                
                public void setAutoSave(boolean value) {
        			autoSave = value;
                }
                
                public void setBiome(int x, int z, Biome bio) {
        			/* TODO */
				}
                public void setChunkForceLoaded(int x, int z, boolean forced) {
        			/* TODO */
				}
                public void setClearWeatherDuration(int duration) {
        			clearWeatherDuration = duration;
                }
                
                public void setDifficulty(Difficulty difficulty) {
        			difficulty = difficulty;
                }
                
                public void setFullTime(long time) {
        			fullTime = time;
                }
                
                public <T> boolean setGameRule(GameRule<T> rule, T newValue) {
        			/* TODO */
				}
                public boolean setGameRuleValue(String rule, String value) {
        			/* TODO */
				}
                public void setHardcore(boolean hardcore) {
        			hardcore = hardcore;
                }
                
                public void setKeepSpawnInMemory(boolean keepLoaded) {
        			keepSpawnInMemory = keepLoaded;
                }
                
                public void setMonsterSpawnLimit(int limit) {
        			monsterSpawnLimit = limit;
                }
                
                public void setPVP(boolean pvp) {
        			pVP = pvp;
                }
                
                public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals) {
        			/* TODO */
				}
                public void setSpawnLimit(SpawnCategory spawnCategory, int limit) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z, float angle) {
        			/* TODO */
				}
                public boolean setSpawnLocation(Location location) {
        			spawnLocation = location;
                }
                
                public void setStorm(boolean hasStorm) {
        			storm = hasStorm;
                }
                
                public void setThunderDuration(int duration) {
        			thunderDuration = duration;
                }
                
                public void setThundering(boolean thundering) {
        			thundering = thundering;
                }
                
                public void setTicksPerAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
        			ticksPerAnimalSpawns = ticksPerAnimalSpawns;
                }
                
                public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
        			ticksPerMonsterSpawns = ticksPerMonsterSpawns;
                }
                
                public void setTicksPerSpawns(SpawnCategory spawnCategory, int ticksPerCategorySpawn) {
        			/* TODO */
				}
                public void setTicksPerWaterAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerWaterAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerWaterSpawns(int ticksPerWaterSpawns) {
        			ticksPerWaterSpawns = ticksPerWaterSpawns;
                }
                
                public void setTicksPerWaterUndergroundCreatureSpawns(int ticksPerWaterUndergroundCreatureSpawns) {
        			ticksPerWaterUndergroundCreatureSpawns = ticksPerWaterUndergroundCreatureSpawns;
                }
                
                public void setTime(long time) {
        			time = time;
                }
                
                public void setWaterAmbientSpawnLimit(int limit) {
        			waterAmbientSpawnLimit = limit;
                }
                
                public void setWaterAnimalSpawnLimit(int limit) {
        			waterAnimalSpawnLimit = limit;
                }
                
                public void setWaterUndergroundCreatureSpawnLimit(int limit) {
        			waterUndergroundCreatureSpawnLimit = limit;
                }
                
                public void setWeatherDuration(int duration) {
        			weatherDuration = duration;
                }
                
				@NotNull
                public Arrow spawnArrow(Location location, Vector direction, float speed, float spread) {
        			/* TODO */
				}
				@NotNull
                <T extends spawnArrow(Location location, Vector direction, float speed, float spread, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, BlockData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, MaterialData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, Material material, byte data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, T data) {
        			/* TODO */
				}
				@NotNull
                public World.Spigot spigot() {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightning(Location loc) {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightningEffect(Location loc) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z, boolean save) {
        			/* TODO */
				}
                public boolean unloadChunk(Chunk chunk) {
        			/* TODO */
				}
                public boolean unloadChunkRequest(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public NamespacedKey getKey() {
        			return key;
			}
                public NamespacedKey key;
        
				@NotNull
                public List<MetadataValue> getMetadata(String metadataKey) {
        			/* TODO */
				}
                public boolean hasMetadata(String metadataKey) {
        			/* TODO */
				}
                public void removeMetadata(String metadataKey, Plugin owningPlugin) {
        			/* TODO */
				}
                public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
        			/* TODO */
				}
				@NotNull
                public PersistentDataContainer getPersistentDataContainer() {
        			return persistentDataContainer;
			}
                public PersistentDataContainer persistentDataContainer;
        
				@NotNull
                public Set<String> getListeningPluginChannels() {
        			return listeningPluginChannels;
			}
                public Set<String> listeningPluginChannels;
        
                public void sendPluginMessage(Plugin source, String channel, byte[] message) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Predicate<BlockState> statePredicate) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Consumer<BlockState> stateConsumer) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(Location location) {
        			/* TODO */
				}
				@NotNull
                public Material getType(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Material getType(Location location) {
        			/* TODO */
				}
                public void setBiome(int x, int y, int z, Biome biome) {
        			/* TODO */
				}
                public void setBiome(Location location, Biome biome) {
        			/* TODO */
				}
                public void setBlockData(int x, int y, int z, BlockData blockData) {
        			/* TODO */
				}
                public void setBlockData(Location location, BlockData blockData) {
        			/* TODO */
				}
                public void setType(int x, int y, int z, Material material) {
        			/* TODO */
				}
                public void setType(Location location, Material material) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, boolean randomizeData, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location location, EntityType type) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location loc, EntityType type, boolean randomizeData) {
        			/* TODO */
				}
				@NotNull
                public World.Environment getEnvironment() {
        			return environment;
			}
                public World.Environment environment;
        
                public int getMaxHeight() {
        			return maxHeight;
			}
                public int maxHeight;
        
                public int getMinHeight() {
        			return minHeight;
			}
                public int minHeight;
        
				@NotNull
                public String getName() {
        			return name;
			}
                public String name;
        
                public long getSeed() {
        			return seed;
			}
                public long seed;
        
				@NotNull
                public UUID getUID() {
        			return uID;
			}
                public UUID uID;
        
            };
            return obj;
        }
    
        org.bukkit.metadata.Metadatable constructMetadatable(String json) {
            Metadatable obj = new Metadatable() {
            
				@NotNull
                public List<MetadataValue> getMetadata(String metadataKey) {
        			/* TODO */
				}
                public boolean hasMetadata(String metadataKey) {
        			/* TODO */
				}
                public void removeMetadata(String metadataKey, Plugin owningPlugin) {
        			/* TODO */
				}
                public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.World constructWorld(String json) {
            World obj = new World() {
            
                public boolean addPluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public boolean canGenerateStructures() {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
                public boolean generateTree(Location location, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
        			/* TODO */
				}
                public boolean getAllowAnimals() {
        			return allowAnimals;
			}
                public boolean allowAnimals;
        
                public boolean getAllowMonsters() {
        			return allowMonsters;
			}
                public boolean allowMonsters;
        
                public int getAmbientSpawnLimit() {
        			return ambientSpawnLimit;
			}
                public int ambientSpawnLimit;
        
                public int getAnimalSpawnLimit() {
        			return animalSpawnLimit;
			}
                public int animalSpawnLimit;
        
				@NotNull
                public Biome getBiome(int x, int z) {
        			/* TODO */
				}
				@Nullable
                public BiomeProvider getBiomeProvider() {
        			return biomeProvider;
			}
                public BiomeProvider biomeProvider;
        
				@NotNull
                public Block getBlockAt(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Block block) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Location location) {
        			/* TODO */
				}
                public int getClearWeatherDuration() {
        			return clearWeatherDuration;
			}
                public int clearWeatherDuration;
        
				@NotNull
                public Difficulty getDifficulty() {
        			return difficulty;
			}
                public Difficulty difficulty;
        
				@NotNull
                public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTemp) {
        			/* TODO */
				}
				@Nullable
                public DragonBattle getEnderDragonBattle() {
        			return enderDragonBattle;
			}
                public DragonBattle enderDragonBattle;
        
				@NotNull
                public List<Entity> getEntities() {
        			return entities;
			}
                public List<Entity> entities;
        
				@NotNull
                <T extends getEntitiesByClass(Class<T> cls) {
        			/* TODO */
				}
				@NotNull
                <T extends getEntitiesByClass(Class<T>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Chunk> getForceLoadedChunks() {
        			return forceLoadedChunks;
			}
                public Collection<Chunk> forceLoadedChunks;
        
                public long getFullTime() {
        			return fullTime;
			}
                public long fullTime;
        
				@Nullable
                public <T> T getGameRuleDefault(GameRule<T> rule) {
        			/* TODO */
				}
				@NotNull
                public String[] getGameRules() {
        			return gameRules;
			}
                public String[] gameRules;
        
				@Nullable
                public String getGameRuleValue(String rule) {
        			/* TODO */
				}
				@Nullable
                public <T> T getGameRuleValue(GameRule<T> rule) {
        			/* TODO */
				}
                public long getGameTime() {
        			return gameTime;
			}
                public long gameTime;
        
				@Nullable
                public ChunkGenerator getGenerator() {
        			return generator;
			}
                public ChunkGenerator generator;
        
				@NotNull
                public Block getHighestBlockAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public double getHumidity(int x, int z) {
        			/* TODO */
				}
                public double getHumidity(int x, int y, int z) {
        			/* TODO */
				}
                public boolean getKeepSpawnInMemory() {
        			return keepSpawnInMemory;
			}
                public boolean keepSpawnInMemory;
        
				@NotNull
                public List<LivingEntity> getLivingEntities() {
        			return livingEntities;
			}
                public List<LivingEntity> livingEntities;
        
				@NotNull
                public Chunk[] getLoadedChunks() {
        			return loadedChunks;
			}
                public Chunk[] loadedChunks;
        
                public int getLogicalHeight() {
        			return logicalHeight;
			}
                public int logicalHeight;
        
                public int getMonsterSpawnLimit() {
        			return monsterSpawnLimit;
			}
                public int monsterSpawnLimit;
        
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public List<Player> getPlayers() {
        			return players;
			}
                public List<Player> players;
        
				@NotNull
                public Map<Plugin,Collection<Chunk>> getPluginChunkTickets() {
        			return pluginChunkTickets;
			}
                public Map<Plugin,Collection<Chunk>> pluginChunkTickets;
        
				@NotNull
                public Collection<Plugin> getPluginChunkTickets(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public List<BlockPopulator> getPopulators() {
        			return populators;
			}
                public List<BlockPopulator> populators;
        
                public boolean getPVP() {
        			return pVP;
			}
                public boolean pVP;
        
				@NotNull
                public List<Raid> getRaids() {
        			return raids;
			}
                public List<Raid> raids;
        
                public int getSeaLevel() {
        			return seaLevel;
			}
                public int seaLevel;
        
                public int getSimulationDistance() {
        			return simulationDistance;
			}
                public int simulationDistance;
        
                public int getSpawnLimit(SpawnCategory spawnCategory) {
        			/* TODO */
				}
				@NotNull
                public Location getSpawnLocation() {
        			return spawnLocation;
			}
                public Location spawnLocation;
        
                public double getTemperature(int x, int z) {
        			/* TODO */
				}
                public double getTemperature(int x, int y, int z) {
        			/* TODO */
				}
                public int getThunderDuration() {
        			return thunderDuration;
			}
                public int thunderDuration;
        
                public long getTicksPerAmbientSpawns() {
        			return ticksPerAmbientSpawns;
			}
                public long ticksPerAmbientSpawns;
        
                public long getTicksPerAnimalSpawns() {
        			return ticksPerAnimalSpawns;
			}
                public long ticksPerAnimalSpawns;
        
                public long getTicksPerMonsterSpawns() {
        			return ticksPerMonsterSpawns;
			}
                public long ticksPerMonsterSpawns;
        
                public long getTicksPerSpawns(SpawnCategory spawnCategory) {
        			/* TODO */
				}
                public long getTicksPerWaterAmbientSpawns() {
        			return ticksPerWaterAmbientSpawns;
			}
                public long ticksPerWaterAmbientSpawns;
        
                public long getTicksPerWaterSpawns() {
        			return ticksPerWaterSpawns;
			}
                public long ticksPerWaterSpawns;
        
                public long getTicksPerWaterUndergroundCreatureSpawns() {
        			return ticksPerWaterUndergroundCreatureSpawns;
			}
                public long ticksPerWaterUndergroundCreatureSpawns;
        
                public long getTime() {
        			return time;
			}
                public long time;
        
                public int getViewDistance() {
        			return viewDistance;
			}
                public int viewDistance;
        
                public int getWaterAmbientSpawnLimit() {
        			return waterAmbientSpawnLimit;
			}
                public int waterAmbientSpawnLimit;
        
                public int getWaterAnimalSpawnLimit() {
        			return waterAnimalSpawnLimit;
			}
                public int waterAnimalSpawnLimit;
        
                public int getWaterUndergroundCreatureSpawnLimit() {
        			return waterUndergroundCreatureSpawnLimit;
			}
                public int waterUndergroundCreatureSpawnLimit;
        
                public int getWeatherDuration() {
        			return weatherDuration;
			}
                public int weatherDuration;
        
				@NotNull
                public WorldBorder getWorldBorder() {
        			return worldBorder;
			}
                public WorldBorder worldBorder;
        
				@NotNull
                public File getWorldFolder() {
        			return worldFolder;
			}
                public File worldFolder;
        
				@Nullable
                public WorldType getWorldType() {
        			return worldType;
			}
                public WorldType worldType;
        
                public boolean hasCeiling() {
        			return ceiling;
			}
                public boolean ceiling;
        
                public boolean hasRaids() {
        			return raids;
			}
                public boolean hasSkyLight() {
        			return skyLight;
			}
                public boolean skyLight;
        
                public boolean hasStorm() {
        			return storm;
			}
                public boolean storm;
        
                public boolean isAutoSave() {
        			return autoSave;
			}
                public boolean autoSave;
        
                public boolean isBedWorks() {
        			return bedWorks;
			}
                public boolean bedWorks;
        
                public boolean isChunkForceLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkGenerated(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkInUse(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(Chunk chunk) {
        			/* TODO */
				}
                public boolean isClearWeather() {
        			return clearWeather;
			}
                public boolean clearWeather;
        
                public boolean isGameRule(String rule) {
        			/* TODO */
				}
                public boolean isHardcore() {
        			return hardcore;
			}
                public boolean hardcore;
        
                public boolean isNatural() {
        			return natural;
			}
                public boolean natural;
        
                public boolean isPiglinSafe() {
        			return piglinSafe;
			}
                public boolean piglinSafe;
        
                public boolean isRespawnAnchorWorks() {
        			return respawnAnchorWorks;
			}
                public boolean respawnAnchorWorks;
        
                public boolean isThundering() {
        			return thundering;
			}
                public boolean thundering;
        
                public boolean isUltraWarm() {
        			return ultraWarm;
			}
                public boolean ultraWarm;
        
                public void loadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean loadChunk(int x, int z, boolean generate) {
        			/* TODO */
				}
                public void loadChunk(Chunk chunk) {
        			/* TODO */
				}
				@Nullable
                public Raid locateNearestRaid(Location location, int radius) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, Structure structure, int radius, boolean findUnexplored) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, StructureType structureType, int radius, boolean findUnexplored) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data, int radius) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data, int radius) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, Predicate<Entity> filter) {
        			/* TODO */
				}
                public boolean refreshChunk(int x, int z) {
        			/* TODO */
				}
                public boolean regenerateChunk(int x, int z) {
        			/* TODO */
				}
                public boolean removePluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public void removePluginChunkTickets(Plugin plugin) {
        			/* TODO */
				}
                public void save() {
        			/* TODO */
				}
                public void setAmbientSpawnLimit(int limit) {
        			ambientSpawnLimit = limit;
                }
                
                public void setAnimalSpawnLimit(int limit) {
        			animalSpawnLimit = limit;
                }
                
                public void setAutoSave(boolean value) {
        			autoSave = value;
                }
                
                public void setBiome(int x, int z, Biome bio) {
        			/* TODO */
				}
                public void setChunkForceLoaded(int x, int z, boolean forced) {
        			/* TODO */
				}
                public void setClearWeatherDuration(int duration) {
        			clearWeatherDuration = duration;
                }
                
                public void setDifficulty(Difficulty difficulty) {
        			difficulty = difficulty;
                }
                
                public void setFullTime(long time) {
        			fullTime = time;
                }
                
                public <T> boolean setGameRule(GameRule<T> rule, T newValue) {
        			/* TODO */
				}
                public boolean setGameRuleValue(String rule, String value) {
        			/* TODO */
				}
                public void setHardcore(boolean hardcore) {
        			hardcore = hardcore;
                }
                
                public void setKeepSpawnInMemory(boolean keepLoaded) {
        			keepSpawnInMemory = keepLoaded;
                }
                
                public void setMonsterSpawnLimit(int limit) {
        			monsterSpawnLimit = limit;
                }
                
                public void setPVP(boolean pvp) {
        			pVP = pvp;
                }
                
                public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals) {
        			/* TODO */
				}
                public void setSpawnLimit(SpawnCategory spawnCategory, int limit) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z, float angle) {
        			/* TODO */
				}
                public boolean setSpawnLocation(Location location) {
        			spawnLocation = location;
                }
                
                public void setStorm(boolean hasStorm) {
        			storm = hasStorm;
                }
                
                public void setThunderDuration(int duration) {
        			thunderDuration = duration;
                }
                
                public void setThundering(boolean thundering) {
        			thundering = thundering;
                }
                
                public void setTicksPerAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
        			ticksPerAnimalSpawns = ticksPerAnimalSpawns;
                }
                
                public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
        			ticksPerMonsterSpawns = ticksPerMonsterSpawns;
                }
                
                public void setTicksPerSpawns(SpawnCategory spawnCategory, int ticksPerCategorySpawn) {
        			/* TODO */
				}
                public void setTicksPerWaterAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerWaterAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerWaterSpawns(int ticksPerWaterSpawns) {
        			ticksPerWaterSpawns = ticksPerWaterSpawns;
                }
                
                public void setTicksPerWaterUndergroundCreatureSpawns(int ticksPerWaterUndergroundCreatureSpawns) {
        			ticksPerWaterUndergroundCreatureSpawns = ticksPerWaterUndergroundCreatureSpawns;
                }
                
                public void setTime(long time) {
        			time = time;
                }
                
                public void setWaterAmbientSpawnLimit(int limit) {
        			waterAmbientSpawnLimit = limit;
                }
                
                public void setWaterAnimalSpawnLimit(int limit) {
        			waterAnimalSpawnLimit = limit;
                }
                
                public void setWaterUndergroundCreatureSpawnLimit(int limit) {
        			waterUndergroundCreatureSpawnLimit = limit;
                }
                
                public void setWeatherDuration(int duration) {
        			weatherDuration = duration;
                }
                
				@NotNull
                public Arrow spawnArrow(Location location, Vector direction, float speed, float spread) {
        			/* TODO */
				}
				@NotNull
                <T extends spawnArrow(Location location, Vector direction, float speed, float spread, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, BlockData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, MaterialData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, Material material, byte data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, T data) {
        			/* TODO */
				}
				@NotNull
                public World.Spigot spigot() {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightning(Location loc) {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightningEffect(Location loc) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z, boolean save) {
        			/* TODO */
				}
                public boolean unloadChunk(Chunk chunk) {
        			/* TODO */
				}
                public boolean unloadChunkRequest(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public NamespacedKey getKey() {
        			return key;
			}
                public NamespacedKey key;
        
				@NotNull
                public List<MetadataValue> getMetadata(String metadataKey) {
        			/* TODO */
				}
                public boolean hasMetadata(String metadataKey) {
        			/* TODO */
				}
                public void removeMetadata(String metadataKey, Plugin owningPlugin) {
        			/* TODO */
				}
                public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
        			/* TODO */
				}
				@NotNull
                public PersistentDataContainer getPersistentDataContainer() {
        			return persistentDataContainer;
			}
                public PersistentDataContainer persistentDataContainer;
        
				@NotNull
                public Set<String> getListeningPluginChannels() {
        			return listeningPluginChannels;
			}
                public Set<String> listeningPluginChannels;
        
                public void sendPluginMessage(Plugin source, String channel, byte[] message) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Predicate<BlockState> statePredicate) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Consumer<BlockState> stateConsumer) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(Location location) {
        			/* TODO */
				}
				@NotNull
                public Material getType(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Material getType(Location location) {
        			/* TODO */
				}
                public void setBiome(int x, int y, int z, Biome biome) {
        			/* TODO */
				}
                public void setBiome(Location location, Biome biome) {
        			/* TODO */
				}
                public void setBlockData(int x, int y, int z, BlockData blockData) {
        			/* TODO */
				}
                public void setBlockData(Location location, BlockData blockData) {
        			/* TODO */
				}
                public void setType(int x, int y, int z, Material material) {
        			/* TODO */
				}
                public void setType(Location location, Material material) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, boolean randomizeData, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location location, EntityType type) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location loc, EntityType type, boolean randomizeData) {
        			/* TODO */
				}
				@NotNull
                public World.Environment getEnvironment() {
        			return environment;
			}
                public World.Environment environment;
        
                public int getMaxHeight() {
        			return maxHeight;
			}
                public int maxHeight;
        
                public int getMinHeight() {
        			return minHeight;
			}
                public int minHeight;
        
				@NotNull
                public String getName() {
        			return name;
			}
                public String name;
        
                public long getSeed() {
        			return seed;
			}
                public long seed;
        
				@NotNull
                public UUID getUID() {
        			return uID;
			}
                public UUID uID;
        
            };
            return obj;
        }
    
        org.bukkit.Nameable constructNameable(String json) {
            Nameable obj = new Nameable() {
            
				@Nullable
                public String getCustomName() {
        			return customName;
			}
                public String customName;
        
                public void setCustomName(String name) {
        			customName = name;
                }
                
            };
            return obj;
        }
    
        org.bukkit.persistence.PersistentDataHolder constructPersistentDataHolder(String json) {
            PersistentDataHolder obj = new PersistentDataHolder() {
            
				@NotNull
                public PersistentDataContainer getPersistentDataContainer() {
        			return persistentDataContainer;
			}
                public PersistentDataContainer persistentDataContainer;
        
            };
            return obj;
        }
    
        org.bukkit.Chunk constructChunk(String json) {
            Chunk obj = new Chunk() {
            
                public boolean addPluginChunkTicket(Plugin plugin) {
        			/* TODO */
				}
                public boolean contains(BlockData block) {
        			/* TODO */
				}
				@NotNull
                public Block getBlock(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public ChunkSnapshot getChunkSnapshot() {
        			return chunkSnapshot;
			}
                public ChunkSnapshot chunkSnapshot;
        
				@NotNull
                public ChunkSnapshot getChunkSnapshot(boolean includeMaxblocky, boolean includeBiome, boolean includeBiomeTempRain) {
        			/* TODO */
				}
				@NotNull
                public Entity[] getEntities() {
        			return entities;
			}
                public Entity[] entities;
        
                public long getInhabitedTime() {
        			return inhabitedTime;
			}
                public long inhabitedTime;
        
				@NotNull
                public Collection<Plugin> getPluginChunkTickets() {
        			return pluginChunkTickets;
			}
                public Collection<Plugin> pluginChunkTickets;
        
				@NotNull
                public BlockState[] getTileEntities() {
        			return tileEntities;
			}
                public BlockState[] tileEntities;
        
				@NotNull
                public World getWorld() {
        			return world;
			}
                public World world;
        
                public int getX() {
        			return x;
			}
                public int x;
        
                public int getZ() {
        			return z;
			}
                public int z;
        
                public boolean isEntitiesLoaded() {
        			return entitiesLoaded;
			}
                public boolean entitiesLoaded;
        
                public boolean isForceLoaded() {
        			return forceLoaded;
			}
                public boolean forceLoaded;
        
                public boolean isLoaded() {
        			return loaded;
			}
                public boolean loaded;
        
                public boolean isSlimeChunk() {
        			return slimeChunk;
			}
                public boolean slimeChunk;
        
                public boolean load() {
        			/* TODO */
				}
                public boolean load(boolean generate) {
        			/* TODO */
				}
                public boolean removePluginChunkTicket(Plugin plugin) {
        			/* TODO */
				}
                public void setForceLoaded(boolean forced) {
        			forceLoaded = forced;
                }
                
                public void setInhabitedTime(long ticks) {
        			inhabitedTime = ticks;
                }
                
                public boolean unload() {
        			/* TODO */
				}
                public boolean unload(boolean save) {
        			/* TODO */
				}
				@NotNull
                public PersistentDataContainer getPersistentDataContainer() {
        			return persistentDataContainer;
			}
                public PersistentDataContainer persistentDataContainer;
        
            };
            return obj;
        }
    
        org.bukkit.World constructWorld(String json) {
            World obj = new World() {
            
                public boolean addPluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public boolean canGenerateStructures() {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
                public boolean generateTree(Location location, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
        			/* TODO */
				}
                public boolean getAllowAnimals() {
        			return allowAnimals;
			}
                public boolean allowAnimals;
        
                public boolean getAllowMonsters() {
        			return allowMonsters;
			}
                public boolean allowMonsters;
        
                public int getAmbientSpawnLimit() {
        			return ambientSpawnLimit;
			}
                public int ambientSpawnLimit;
        
                public int getAnimalSpawnLimit() {
        			return animalSpawnLimit;
			}
                public int animalSpawnLimit;
        
				@NotNull
                public Biome getBiome(int x, int z) {
        			/* TODO */
				}
				@Nullable
                public BiomeProvider getBiomeProvider() {
        			return biomeProvider;
			}
                public BiomeProvider biomeProvider;
        
				@NotNull
                public Block getBlockAt(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Block block) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Location location) {
        			/* TODO */
				}
                public int getClearWeatherDuration() {
        			return clearWeatherDuration;
			}
                public int clearWeatherDuration;
        
				@NotNull
                public Difficulty getDifficulty() {
        			return difficulty;
			}
                public Difficulty difficulty;
        
				@NotNull
                public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTemp) {
        			/* TODO */
				}
				@Nullable
                public DragonBattle getEnderDragonBattle() {
        			return enderDragonBattle;
			}
                public DragonBattle enderDragonBattle;
        
				@NotNull
                public List<Entity> getEntities() {
        			return entities;
			}
                public List<Entity> entities;
        
				@NotNull
                <T extends getEntitiesByClass(Class<T> cls) {
        			/* TODO */
				}
				@NotNull
                <T extends getEntitiesByClass(Class<T>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Chunk> getForceLoadedChunks() {
        			return forceLoadedChunks;
			}
                public Collection<Chunk> forceLoadedChunks;
        
                public long getFullTime() {
        			return fullTime;
			}
                public long fullTime;
        
				@Nullable
                public <T> T getGameRuleDefault(GameRule<T> rule) {
        			/* TODO */
				}
				@NotNull
                public String[] getGameRules() {
        			return gameRules;
			}
                public String[] gameRules;
        
				@Nullable
                public String getGameRuleValue(String rule) {
        			/* TODO */
				}
				@Nullable
                public <T> T getGameRuleValue(GameRule<T> rule) {
        			/* TODO */
				}
                public long getGameTime() {
        			return gameTime;
			}
                public long gameTime;
        
				@Nullable
                public ChunkGenerator getGenerator() {
        			return generator;
			}
                public ChunkGenerator generator;
        
				@NotNull
                public Block getHighestBlockAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public double getHumidity(int x, int z) {
        			/* TODO */
				}
                public double getHumidity(int x, int y, int z) {
        			/* TODO */
				}
                public boolean getKeepSpawnInMemory() {
        			return keepSpawnInMemory;
			}
                public boolean keepSpawnInMemory;
        
				@NotNull
                public List<LivingEntity> getLivingEntities() {
        			return livingEntities;
			}
                public List<LivingEntity> livingEntities;
        
				@NotNull
                public Chunk[] getLoadedChunks() {
        			return loadedChunks;
			}
                public Chunk[] loadedChunks;
        
                public int getLogicalHeight() {
        			return logicalHeight;
			}
                public int logicalHeight;
        
                public int getMonsterSpawnLimit() {
        			return monsterSpawnLimit;
			}
                public int monsterSpawnLimit;
        
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public List<Player> getPlayers() {
        			return players;
			}
                public List<Player> players;
        
				@NotNull
                public Map<Plugin,Collection<Chunk>> getPluginChunkTickets() {
        			return pluginChunkTickets;
			}
                public Map<Plugin,Collection<Chunk>> pluginChunkTickets;
        
				@NotNull
                public Collection<Plugin> getPluginChunkTickets(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public List<BlockPopulator> getPopulators() {
        			return populators;
			}
                public List<BlockPopulator> populators;
        
                public boolean getPVP() {
        			return pVP;
			}
                public boolean pVP;
        
				@NotNull
                public List<Raid> getRaids() {
        			return raids;
			}
                public List<Raid> raids;
        
                public int getSeaLevel() {
        			return seaLevel;
			}
                public int seaLevel;
        
                public int getSimulationDistance() {
        			return simulationDistance;
			}
                public int simulationDistance;
        
                public int getSpawnLimit(SpawnCategory spawnCategory) {
        			/* TODO */
				}
				@NotNull
                public Location getSpawnLocation() {
        			return spawnLocation;
			}
                public Location spawnLocation;
        
                public double getTemperature(int x, int z) {
        			/* TODO */
				}
                public double getTemperature(int x, int y, int z) {
        			/* TODO */
				}
                public int getThunderDuration() {
        			return thunderDuration;
			}
                public int thunderDuration;
        
                public long getTicksPerAmbientSpawns() {
        			return ticksPerAmbientSpawns;
			}
                public long ticksPerAmbientSpawns;
        
                public long getTicksPerAnimalSpawns() {
        			return ticksPerAnimalSpawns;
			}
                public long ticksPerAnimalSpawns;
        
                public long getTicksPerMonsterSpawns() {
        			return ticksPerMonsterSpawns;
			}
                public long ticksPerMonsterSpawns;
        
                public long getTicksPerSpawns(SpawnCategory spawnCategory) {
        			/* TODO */
				}
                public long getTicksPerWaterAmbientSpawns() {
        			return ticksPerWaterAmbientSpawns;
			}
                public long ticksPerWaterAmbientSpawns;
        
                public long getTicksPerWaterSpawns() {
        			return ticksPerWaterSpawns;
			}
                public long ticksPerWaterSpawns;
        
                public long getTicksPerWaterUndergroundCreatureSpawns() {
        			return ticksPerWaterUndergroundCreatureSpawns;
			}
                public long ticksPerWaterUndergroundCreatureSpawns;
        
                public long getTime() {
        			return time;
			}
                public long time;
        
                public int getViewDistance() {
        			return viewDistance;
			}
                public int viewDistance;
        
                public int getWaterAmbientSpawnLimit() {
        			return waterAmbientSpawnLimit;
			}
                public int waterAmbientSpawnLimit;
        
                public int getWaterAnimalSpawnLimit() {
        			return waterAnimalSpawnLimit;
			}
                public int waterAnimalSpawnLimit;
        
                public int getWaterUndergroundCreatureSpawnLimit() {
        			return waterUndergroundCreatureSpawnLimit;
			}
                public int waterUndergroundCreatureSpawnLimit;
        
                public int getWeatherDuration() {
        			return weatherDuration;
			}
                public int weatherDuration;
        
				@NotNull
                public WorldBorder getWorldBorder() {
        			return worldBorder;
			}
                public WorldBorder worldBorder;
        
				@NotNull
                public File getWorldFolder() {
        			return worldFolder;
			}
                public File worldFolder;
        
				@Nullable
                public WorldType getWorldType() {
        			return worldType;
			}
                public WorldType worldType;
        
                public boolean hasCeiling() {
        			return ceiling;
			}
                public boolean ceiling;
        
                public boolean hasRaids() {
        			return raids;
			}
                public boolean hasSkyLight() {
        			return skyLight;
			}
                public boolean skyLight;
        
                public boolean hasStorm() {
        			return storm;
			}
                public boolean storm;
        
                public boolean isAutoSave() {
        			return autoSave;
			}
                public boolean autoSave;
        
                public boolean isBedWorks() {
        			return bedWorks;
			}
                public boolean bedWorks;
        
                public boolean isChunkForceLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkGenerated(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkInUse(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(Chunk chunk) {
        			/* TODO */
				}
                public boolean isClearWeather() {
        			return clearWeather;
			}
                public boolean clearWeather;
        
                public boolean isGameRule(String rule) {
        			/* TODO */
				}
                public boolean isHardcore() {
        			return hardcore;
			}
                public boolean hardcore;
        
                public boolean isNatural() {
        			return natural;
			}
                public boolean natural;
        
                public boolean isPiglinSafe() {
        			return piglinSafe;
			}
                public boolean piglinSafe;
        
                public boolean isRespawnAnchorWorks() {
        			return respawnAnchorWorks;
			}
                public boolean respawnAnchorWorks;
        
                public boolean isThundering() {
        			return thundering;
			}
                public boolean thundering;
        
                public boolean isUltraWarm() {
        			return ultraWarm;
			}
                public boolean ultraWarm;
        
                public void loadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean loadChunk(int x, int z, boolean generate) {
        			/* TODO */
				}
                public void loadChunk(Chunk chunk) {
        			/* TODO */
				}
				@Nullable
                public Raid locateNearestRaid(Location location, int radius) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, Structure structure, int radius, boolean findUnexplored) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, StructureType structureType, int radius, boolean findUnexplored) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data, int radius) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data, int radius) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, Predicate<Entity> filter) {
        			/* TODO */
				}
                public boolean refreshChunk(int x, int z) {
        			/* TODO */
				}
                public boolean regenerateChunk(int x, int z) {
        			/* TODO */
				}
                public boolean removePluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public void removePluginChunkTickets(Plugin plugin) {
        			/* TODO */
				}
                public void save() {
        			/* TODO */
				}
                public void setAmbientSpawnLimit(int limit) {
        			ambientSpawnLimit = limit;
                }
                
                public void setAnimalSpawnLimit(int limit) {
        			animalSpawnLimit = limit;
                }
                
                public void setAutoSave(boolean value) {
        			autoSave = value;
                }
                
                public void setBiome(int x, int z, Biome bio) {
        			/* TODO */
				}
                public void setChunkForceLoaded(int x, int z, boolean forced) {
        			/* TODO */
				}
                public void setClearWeatherDuration(int duration) {
        			clearWeatherDuration = duration;
                }
                
                public void setDifficulty(Difficulty difficulty) {
        			difficulty = difficulty;
                }
                
                public void setFullTime(long time) {
        			fullTime = time;
                }
                
                public <T> boolean setGameRule(GameRule<T> rule, T newValue) {
        			/* TODO */
				}
                public boolean setGameRuleValue(String rule, String value) {
        			/* TODO */
				}
                public void setHardcore(boolean hardcore) {
        			hardcore = hardcore;
                }
                
                public void setKeepSpawnInMemory(boolean keepLoaded) {
        			keepSpawnInMemory = keepLoaded;
                }
                
                public void setMonsterSpawnLimit(int limit) {
        			monsterSpawnLimit = limit;
                }
                
                public void setPVP(boolean pvp) {
        			pVP = pvp;
                }
                
                public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals) {
        			/* TODO */
				}
                public void setSpawnLimit(SpawnCategory spawnCategory, int limit) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z, float angle) {
        			/* TODO */
				}
                public boolean setSpawnLocation(Location location) {
        			spawnLocation = location;
                }
                
                public void setStorm(boolean hasStorm) {
        			storm = hasStorm;
                }
                
                public void setThunderDuration(int duration) {
        			thunderDuration = duration;
                }
                
                public void setThundering(boolean thundering) {
        			thundering = thundering;
                }
                
                public void setTicksPerAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
        			ticksPerAnimalSpawns = ticksPerAnimalSpawns;
                }
                
                public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
        			ticksPerMonsterSpawns = ticksPerMonsterSpawns;
                }
                
                public void setTicksPerSpawns(SpawnCategory spawnCategory, int ticksPerCategorySpawn) {
        			/* TODO */
				}
                public void setTicksPerWaterAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerWaterAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerWaterSpawns(int ticksPerWaterSpawns) {
        			ticksPerWaterSpawns = ticksPerWaterSpawns;
                }
                
                public void setTicksPerWaterUndergroundCreatureSpawns(int ticksPerWaterUndergroundCreatureSpawns) {
        			ticksPerWaterUndergroundCreatureSpawns = ticksPerWaterUndergroundCreatureSpawns;
                }
                
                public void setTime(long time) {
        			time = time;
                }
                
                public void setWaterAmbientSpawnLimit(int limit) {
        			waterAmbientSpawnLimit = limit;
                }
                
                public void setWaterAnimalSpawnLimit(int limit) {
        			waterAnimalSpawnLimit = limit;
                }
                
                public void setWaterUndergroundCreatureSpawnLimit(int limit) {
        			waterUndergroundCreatureSpawnLimit = limit;
                }
                
                public void setWeatherDuration(int duration) {
        			weatherDuration = duration;
                }
                
				@NotNull
                public Arrow spawnArrow(Location location, Vector direction, float speed, float spread) {
        			/* TODO */
				}
				@NotNull
                <T extends spawnArrow(Location location, Vector direction, float speed, float spread, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, BlockData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, MaterialData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, Material material, byte data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, T data) {
        			/* TODO */
				}
				@NotNull
                public World.Spigot spigot() {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightning(Location loc) {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightningEffect(Location loc) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z, boolean save) {
        			/* TODO */
				}
                public boolean unloadChunk(Chunk chunk) {
        			/* TODO */
				}
                public boolean unloadChunkRequest(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public NamespacedKey getKey() {
        			return key;
			}
                public NamespacedKey key;
        
				@NotNull
                public List<MetadataValue> getMetadata(String metadataKey) {
        			/* TODO */
				}
                public boolean hasMetadata(String metadataKey) {
        			/* TODO */
				}
                public void removeMetadata(String metadataKey, Plugin owningPlugin) {
        			/* TODO */
				}
                public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
        			/* TODO */
				}
				@NotNull
                public PersistentDataContainer getPersistentDataContainer() {
        			return persistentDataContainer;
			}
                public PersistentDataContainer persistentDataContainer;
        
				@NotNull
                public Set<String> getListeningPluginChannels() {
        			return listeningPluginChannels;
			}
                public Set<String> listeningPluginChannels;
        
                public void sendPluginMessage(Plugin source, String channel, byte[] message) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Predicate<BlockState> statePredicate) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Consumer<BlockState> stateConsumer) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(Location location) {
        			/* TODO */
				}
				@NotNull
                public Material getType(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Material getType(Location location) {
        			/* TODO */
				}
                public void setBiome(int x, int y, int z, Biome biome) {
        			/* TODO */
				}
                public void setBiome(Location location, Biome biome) {
        			/* TODO */
				}
                public void setBlockData(int x, int y, int z, BlockData blockData) {
        			/* TODO */
				}
                public void setBlockData(Location location, BlockData blockData) {
        			/* TODO */
				}
                public void setType(int x, int y, int z, Material material) {
        			/* TODO */
				}
                public void setType(Location location, Material material) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, boolean randomizeData, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location location, EntityType type) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location loc, EntityType type, boolean randomizeData) {
        			/* TODO */
				}
				@NotNull
                public World.Environment getEnvironment() {
        			return environment;
			}
                public World.Environment environment;
        
                public int getMaxHeight() {
        			return maxHeight;
			}
                public int maxHeight;
        
                public int getMinHeight() {
        			return minHeight;
			}
                public int minHeight;
        
				@NotNull
                public String getName() {
        			return name;
			}
                public String name;
        
                public long getSeed() {
        			return seed;
			}
                public long seed;
        
				@NotNull
                public UUID getUID() {
        			return uID;
			}
                public UUID uID;
        
            };
            return obj;
        }
    
        org.bukkit.plugin.messaging.PluginMessageRecipient constructPluginMessageRecipient(String json) {
            PluginMessageRecipient obj = new PluginMessageRecipient() {
            
				@NotNull
                public Set<String> getListeningPluginChannels() {
        			return listeningPluginChannels;
			}
                public Set<String> listeningPluginChannels;
        
                public void sendPluginMessage(Plugin source, String channel, byte[] message) {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.Server constructServer(String json) {
            Server obj = new Server() {
            
                public boolean addRecipe(Recipe recipe) {
        			/* TODO */
				}
				@NotNull
                public Iterator<Advancement> advancementIterator() {
        			/* TODO */
				}
                public void banIP(String address) {
        			/* TODO */
				}
                public int broadcast(String message, String permission) {
        			/* TODO */
				}
                public int broadcastMessage(String message) {
        			/* TODO */
				}
                public void clearRecipes() {
        			/* TODO */
				}
				@NotNull
                public ItemStack craftItem(ItemStack[] craftingMatrix, World world, Player player) {
        			/* TODO */
				}
				@NotNull
                public BlockData createBlockData(String data) {
        			/* TODO */
				}
				@NotNull
                public BlockData createBlockData(Material material) {
        			/* TODO */
				}
				@NotNull
                public BlockData createBlockData(Material material, String data) {
        			/* TODO */
				}
				@NotNull
                public BlockData createBlockData(Material material, Consumer<BlockData> consumer) {
        			/* TODO */
				}
				@NotNull
                public BossBar createBossBar(String title, BarColor color, BarStyle style, BarFlag... flags) {
        			/* TODO */
				}
				@NotNull
                public KeyedBossBar createBossBar(NamespacedKey key, String title, BarColor color, BarStyle style, BarFlag... flags) {
        			/* TODO */
				}
				@NotNull
                public ChunkGenerator.ChunkData createChunkData(World world) {
        			/* TODO */
				}
				@NotNull
                public ItemStack createExplorerMap(World world, Location location, StructureType structureType) {
        			/* TODO */
				}
				@NotNull
                public ItemStack createExplorerMap(World world, Location location, StructureType structureType, int radius, boolean findUnexplored) {
        			/* TODO */
				}
				@NotNull
                public Inventory createInventory(InventoryHolder owner, int size) {
        			/* TODO */
				}
				@NotNull
                public Inventory createInventory(InventoryHolder owner, int size, String title) {
        			/* TODO */
				}
				@NotNull
                public Inventory createInventory(InventoryHolder owner, InventoryType type) {
        			/* TODO */
				}
				@NotNull
                public Inventory createInventory(InventoryHolder owner, InventoryType type, String title) {
        			/* TODO */
				}
				@NotNull
                public MapView createMap(World world) {
        			/* TODO */
				}
				@NotNull
                public Merchant createMerchant(String title) {
        			/* TODO */
				}
				@NotNull
                public PlayerProfile createPlayerProfile(String name) {
        			/* TODO */
				}
				@NotNull
                public PlayerProfile createPlayerProfile(UUID uniqueId) {
        			/* TODO */
				}
				@NotNull
                public PlayerProfile createPlayerProfile(UUID uniqueId, String name) {
        			/* TODO */
				}
				@Nullable
                public World createWorld(WorldCreator creator) {
        			/* TODO */
				}
				@NotNull
                public WorldBorder createWorldBorder() {
        			/* TODO */
				}
                public boolean dispatchCommand(CommandSender sender, String commandLine) {
        			/* TODO */
				}
				@Nullable
                public Advancement getAdvancement(NamespacedKey key) {
        			/* TODO */
				}
                public boolean getAllowEnd() {
        			return allowEnd;
			}
                public boolean allowEnd;
        
                public boolean getAllowFlight() {
        			return allowFlight;
			}
                public boolean allowFlight;
        
                public boolean getAllowNether() {
        			return allowNether;
			}
                public boolean allowNether;
        
                public int getAmbientSpawnLimit() {
        			return ambientSpawnLimit;
			}
                public int ambientSpawnLimit;
        
                public int getAnimalSpawnLimit() {
        			return animalSpawnLimit;
			}
                public int animalSpawnLimit;
        
				@NotNull
                public BanList getBanList(BanList.Type type) {
        			/* TODO */
				}
				@NotNull
                public Set<OfflinePlayer> getBannedPlayers() {
        			return bannedPlayers;
			}
                public Set<OfflinePlayer> bannedPlayers;
        
				@Nullable
                public KeyedBossBar getBossBar(NamespacedKey key) {
        			/* TODO */
				}
				@NotNull
                public Iterator<KeyedBossBar> getBossBars() {
        			return bossBars;
			}
                public Iterator<KeyedBossBar> bossBars;
        
				@NotNull
                public String getBukkitVersion() {
        			return bukkitVersion;
			}
                public String bukkitVersion;
        
				@NotNull
                public Map<String,String[]> getCommandAliases() {
        			return commandAliases;
			}
                public Map<String,String[]> commandAliases;
        
                public long getConnectionThrottle() {
        			return connectionThrottle;
			}
                public long connectionThrottle;
        
				@NotNull
                public ConsoleCommandSender getConsoleSender() {
        			return consoleSender;
			}
                public ConsoleCommandSender consoleSender;
        
				@Nullable
                public Recipe getCraftingRecipe(ItemStack[] craftingMatrix, World world) {
        			/* TODO */
				}
				@NotNull
                public GameMode getDefaultGameMode() {
        			return defaultGameMode;
			}
                public GameMode defaultGameMode;
        
				@Nullable
                public Entity getEntity(UUID uuid) {
        			/* TODO */
				}
                public boolean getGenerateStructures() {
        			return generateStructures;
			}
                public boolean generateStructures;
        
				@NotNull
                public HelpMap getHelpMap() {
        			return helpMap;
			}
                public HelpMap helpMap;
        
                public boolean getHideOnlinePlayers() {
        			return hideOnlinePlayers;
			}
                public boolean hideOnlinePlayers;
        
                public int getIdleTimeout() {
        			return idleTimeout;
			}
                public int idleTimeout;
        
				@NotNull
                public String getIp() {
        			return ip;
			}
                public String ip;
        
				@NotNull
                public Set<String> getIPBans() {
        			return iPBans;
			}
                public Set<String> iPBans;
        
				@NotNull
                public ItemFactory getItemFactory() {
        			return itemFactory;
			}
                public ItemFactory itemFactory;
        
				@NotNull
                public Logger getLogger() {
        			return logger;
			}
                public Logger logger;
        
				@Nullable
                public LootTable getLootTable(NamespacedKey key) {
        			/* TODO */
				}
                public MapView getMap(int id) {
        			/* TODO */
				}
                public int getMaxChainedNeighborUpdates() {
        			return maxChainedNeighborUpdates;
			}
                public int maxChainedNeighborUpdates;
        
                public int getMaxPlayers() {
        			return maxPlayers;
			}
                public int maxPlayers;
        
                public int getMaxWorldSize() {
        			return maxWorldSize;
			}
                public int maxWorldSize;
        
				@NotNull
                public Messenger getMessenger() {
        			return messenger;
			}
                public Messenger messenger;
        
                public int getMonsterSpawnLimit() {
        			return monsterSpawnLimit;
			}
                public int monsterSpawnLimit;
        
				@NotNull
                public String getMotd() {
        			return motd;
			}
                public String motd;
        
				@NotNull
                public String getName() {
        			return name;
			}
                public String name;
        
				@NotNull
                public OfflinePlayer getOfflinePlayer(String name) {
        			/* TODO */
				}
				@NotNull
                public OfflinePlayer getOfflinePlayer(UUID id) {
        			/* TODO */
				}
				@NotNull
                public OfflinePlayer[] getOfflinePlayers() {
        			return offlinePlayers;
			}
                public OfflinePlayer[] offlinePlayers;
        
                public boolean getOnlineMode() {
        			return onlineMode;
			}
                public boolean onlineMode;
        
				@NotNull
                Collection<? extends getOnlinePlayers() {
        			return onlinePlayers;
			}
                Collection<? extends onlinePlayers;
        
				@NotNull
                public Set<OfflinePlayer> getOperators() {
        			return operators;
			}
                public Set<OfflinePlayer> operators;
        
				@Nullable
                public Player getPlayer(String name) {
        			/* TODO */
				}
				@Nullable
                public Player getPlayer(UUID id) {
        			/* TODO */
				}
				@Nullable
                public Player getPlayerExact(String name) {
        			/* TODO */
				}
				@Nullable
                public PluginCommand getPluginCommand(String name) {
        			/* TODO */
				}
				@NotNull
                public PluginManager getPluginManager() {
        			return pluginManager;
			}
                public PluginManager pluginManager;
        
                public int getPort() {
        			return port;
			}
                public int port;
        
				@Nullable
                public Recipe getRecipe(NamespacedKey recipeKey) {
        			/* TODO */
				}
				@NotNull
                public List<Recipe> getRecipesFor(ItemStack result) {
        			/* TODO */
				}
				@Nullable
                <T extends getRegistry(Class<T> tClass) {
        			/* TODO */
				}
				@NotNull
                public String getResourcePack() {
        			return resourcePack;
			}
                public String resourcePack;
        
				@NotNull
                public String getResourcePackHash() {
        			return resourcePackHash;
			}
                public String resourcePackHash;
        
				@NotNull
                public String getResourcePackPrompt() {
        			return resourcePackPrompt;
			}
                public String resourcePackPrompt;
        
				@NotNull
                public BukkitScheduler getScheduler() {
        			return scheduler;
			}
                public BukkitScheduler scheduler;
        
				@NotNull
                public Criteria getScoreboardCriteria(String name) {
        			/* TODO */
				}
				@Nullable
                public ScoreboardManager getScoreboardManager() {
        			return scoreboardManager;
			}
                public ScoreboardManager scoreboardManager;
        
				@Nullable
                public CachedServerIcon getServerIcon() {
        			return serverIcon;
			}
                public CachedServerIcon serverIcon;
        
				@NotNull
                public ServicesManager getServicesManager() {
        			return servicesManager;
			}
                public ServicesManager servicesManager;
        
				@Nullable
                public String getShutdownMessage() {
        			return shutdownMessage;
			}
                public String shutdownMessage;
        
                public int getSimulationDistance() {
        			return simulationDistance;
			}
                public int simulationDistance;
        
                public int getSpawnLimit(SpawnCategory spawnCategory) {
        			/* TODO */
				}
                public int getSpawnRadius() {
        			return spawnRadius;
			}
                public int spawnRadius;
        
				@NotNull
                public StructureManager getStructureManager() {
        			return structureManager;
			}
                public StructureManager structureManager;
        
				@Nullable
                <T extends getTag(String registry, NamespacedKey tag, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                <T extends getTags(String registry, Class<T> clazz) {
        			/* TODO */
				}
                public int getTicksPerAmbientSpawns() {
        			return ticksPerAmbientSpawns;
			}
                public int ticksPerAmbientSpawns;
        
                public int getTicksPerAnimalSpawns() {
        			return ticksPerAnimalSpawns;
			}
                public int ticksPerAnimalSpawns;
        
                public int getTicksPerMonsterSpawns() {
        			return ticksPerMonsterSpawns;
			}
                public int ticksPerMonsterSpawns;
        
                public int getTicksPerSpawns(SpawnCategory spawnCategory) {
        			/* TODO */
				}
                public int getTicksPerWaterAmbientSpawns() {
        			return ticksPerWaterAmbientSpawns;
			}
                public int ticksPerWaterAmbientSpawns;
        
                public int getTicksPerWaterSpawns() {
        			return ticksPerWaterSpawns;
			}
                public int ticksPerWaterSpawns;
        
                public int getTicksPerWaterUndergroundCreatureSpawns() {
        			return ticksPerWaterUndergroundCreatureSpawns;
			}
                public int ticksPerWaterUndergroundCreatureSpawns;
        
                public UnsafeValues getUnsafe() {
        			return unsafe;
			}
                public UnsafeValues unsafe;
        
				@NotNull
                public String getUpdateFolder() {
        			return updateFolder;
			}
                public String updateFolder;
        
				@NotNull
                public File getUpdateFolderFile() {
        			return updateFolderFile;
			}
                public File updateFolderFile;
        
				@NotNull
                public String getVersion() {
        			return version;
			}
                public String version;
        
                public int getViewDistance() {
        			return viewDistance;
			}
                public int viewDistance;
        
				@NotNull
                public Warning.WarningState getWarningState() {
        			return warningState;
			}
                public Warning.WarningState warningState;
        
                public int getWaterAmbientSpawnLimit() {
        			return waterAmbientSpawnLimit;
			}
                public int waterAmbientSpawnLimit;
        
                public int getWaterAnimalSpawnLimit() {
        			return waterAnimalSpawnLimit;
			}
                public int waterAnimalSpawnLimit;
        
                public int getWaterUndergroundCreatureSpawnLimit() {
        			return waterUndergroundCreatureSpawnLimit;
			}
                public int waterUndergroundCreatureSpawnLimit;
        
				@NotNull
                public Set<OfflinePlayer> getWhitelistedPlayers() {
        			return whitelistedPlayers;
			}
                public Set<OfflinePlayer> whitelistedPlayers;
        
				@Nullable
                public World getWorld(String name) {
        			/* TODO */
				}
				@Nullable
                public World getWorld(UUID uid) {
        			/* TODO */
				}
				@NotNull
                public File getWorldContainer() {
        			return worldContainer;
			}
                public File worldContainer;
        
				@NotNull
                public List<World> getWorlds() {
        			return worlds;
			}
                public List<World> worlds;
        
				@NotNull
                public String getWorldType() {
        			return worldType;
			}
                public String worldType;
        
                public boolean hasWhitelist() {
        			return whitelist;
			}
                public boolean whitelist;
        
                public boolean isEnforcingSecureProfiles() {
        			return enforcingSecureProfiles;
			}
                public boolean enforcingSecureProfiles;
        
                public boolean isHardcore() {
        			return hardcore;
			}
                public boolean hardcore;
        
                public boolean isPrimaryThread() {
        			return primaryThread;
			}
                public boolean primaryThread;
        
                public boolean isResourcePackRequired() {
        			return resourcePackRequired;
			}
                public boolean resourcePackRequired;
        
                public boolean isWhitelistEnforced() {
        			return whitelistEnforced;
			}
                public boolean whitelistEnforced;
        
				@NotNull
                public CachedServerIcon loadServerIcon(BufferedImage image) {
        			/* TODO */
				}
				@NotNull
                public CachedServerIcon loadServerIcon(File file) {
        			/* TODO */
				}
				@NotNull
                public List<Player> matchPlayer(String name) {
        			/* TODO */
				}
				@NotNull
                public Iterator<Recipe> recipeIterator() {
        			/* TODO */
				}
                public void reload() {
        			/* TODO */
				}
                public void reloadData() {
        			/* TODO */
				}
                public void reloadWhitelist() {
        			/* TODO */
				}
                public boolean removeBossBar(NamespacedKey key) {
        			/* TODO */
				}
                public boolean removeRecipe(NamespacedKey key) {
        			/* TODO */
				}
                public void resetRecipes() {
        			/* TODO */
				}
                public void savePlayers() {
        			/* TODO */
				}
				@NotNull
                public List<Entity> selectEntities(CommandSender sender, String selector) {
        			/* TODO */
				}
                public void setDefaultGameMode(GameMode mode) {
        			defaultGameMode = mode;
                }
                
                public void setIdleTimeout(int threshold) {
        			idleTimeout = threshold;
                }
                
                public void setSpawnRadius(int value) {
        			spawnRadius = value;
                }
                
                public void setWhitelist(boolean value) {
        			whitelist = value;
                }
                
                public void setWhitelistEnforced(boolean value) {
        			whitelistEnforced = value;
                }
                
                public boolean shouldSendChatPreviews() {
        			/* TODO */
				}
                public void shutdown() {
        			/* TODO */
				}
				@NotNull
                public Server.Spigot spigot() {
        			/* TODO */
				}
                public void unbanIP(String address) {
        			/* TODO */
				}
                public boolean unloadWorld(String name, boolean save) {
        			/* TODO */
				}
                public boolean unloadWorld(World world, boolean save) {
        			/* TODO */
				}
				@NotNull
                public Set<String> getListeningPluginChannels() {
        			return listeningPluginChannels;
			}
                public Set<String> listeningPluginChannels;
        
                public void sendPluginMessage(Plugin source, String channel, byte[] message) {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.World constructWorld(String json) {
            World obj = new World() {
            
                public boolean addPluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public boolean canGenerateStructures() {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
                public boolean generateTree(Location location, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
        			/* TODO */
				}
                public boolean getAllowAnimals() {
        			return allowAnimals;
			}
                public boolean allowAnimals;
        
                public boolean getAllowMonsters() {
        			return allowMonsters;
			}
                public boolean allowMonsters;
        
                public int getAmbientSpawnLimit() {
        			return ambientSpawnLimit;
			}
                public int ambientSpawnLimit;
        
                public int getAnimalSpawnLimit() {
        			return animalSpawnLimit;
			}
                public int animalSpawnLimit;
        
				@NotNull
                public Biome getBiome(int x, int z) {
        			/* TODO */
				}
				@Nullable
                public BiomeProvider getBiomeProvider() {
        			return biomeProvider;
			}
                public BiomeProvider biomeProvider;
        
				@NotNull
                public Block getBlockAt(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Block block) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Location location) {
        			/* TODO */
				}
                public int getClearWeatherDuration() {
        			return clearWeatherDuration;
			}
                public int clearWeatherDuration;
        
				@NotNull
                public Difficulty getDifficulty() {
        			return difficulty;
			}
                public Difficulty difficulty;
        
				@NotNull
                public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTemp) {
        			/* TODO */
				}
				@Nullable
                public DragonBattle getEnderDragonBattle() {
        			return enderDragonBattle;
			}
                public DragonBattle enderDragonBattle;
        
				@NotNull
                public List<Entity> getEntities() {
        			return entities;
			}
                public List<Entity> entities;
        
				@NotNull
                <T extends getEntitiesByClass(Class<T> cls) {
        			/* TODO */
				}
				@NotNull
                <T extends getEntitiesByClass(Class<T>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Chunk> getForceLoadedChunks() {
        			return forceLoadedChunks;
			}
                public Collection<Chunk> forceLoadedChunks;
        
                public long getFullTime() {
        			return fullTime;
			}
                public long fullTime;
        
				@Nullable
                public <T> T getGameRuleDefault(GameRule<T> rule) {
        			/* TODO */
				}
				@NotNull
                public String[] getGameRules() {
        			return gameRules;
			}
                public String[] gameRules;
        
				@Nullable
                public String getGameRuleValue(String rule) {
        			/* TODO */
				}
				@Nullable
                public <T> T getGameRuleValue(GameRule<T> rule) {
        			/* TODO */
				}
                public long getGameTime() {
        			return gameTime;
			}
                public long gameTime;
        
				@Nullable
                public ChunkGenerator getGenerator() {
        			return generator;
			}
                public ChunkGenerator generator;
        
				@NotNull
                public Block getHighestBlockAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public double getHumidity(int x, int z) {
        			/* TODO */
				}
                public double getHumidity(int x, int y, int z) {
        			/* TODO */
				}
                public boolean getKeepSpawnInMemory() {
        			return keepSpawnInMemory;
			}
                public boolean keepSpawnInMemory;
        
				@NotNull
                public List<LivingEntity> getLivingEntities() {
        			return livingEntities;
			}
                public List<LivingEntity> livingEntities;
        
				@NotNull
                public Chunk[] getLoadedChunks() {
        			return loadedChunks;
			}
                public Chunk[] loadedChunks;
        
                public int getLogicalHeight() {
        			return logicalHeight;
			}
                public int logicalHeight;
        
                public int getMonsterSpawnLimit() {
        			return monsterSpawnLimit;
			}
                public int monsterSpawnLimit;
        
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public List<Player> getPlayers() {
        			return players;
			}
                public List<Player> players;
        
				@NotNull
                public Map<Plugin,Collection<Chunk>> getPluginChunkTickets() {
        			return pluginChunkTickets;
			}
                public Map<Plugin,Collection<Chunk>> pluginChunkTickets;
        
				@NotNull
                public Collection<Plugin> getPluginChunkTickets(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public List<BlockPopulator> getPopulators() {
        			return populators;
			}
                public List<BlockPopulator> populators;
        
                public boolean getPVP() {
        			return pVP;
			}
                public boolean pVP;
        
				@NotNull
                public List<Raid> getRaids() {
        			return raids;
			}
                public List<Raid> raids;
        
                public int getSeaLevel() {
        			return seaLevel;
			}
                public int seaLevel;
        
                public int getSimulationDistance() {
        			return simulationDistance;
			}
                public int simulationDistance;
        
                public int getSpawnLimit(SpawnCategory spawnCategory) {
        			/* TODO */
				}
				@NotNull
                public Location getSpawnLocation() {
        			return spawnLocation;
			}
                public Location spawnLocation;
        
                public double getTemperature(int x, int z) {
        			/* TODO */
				}
                public double getTemperature(int x, int y, int z) {
        			/* TODO */
				}
                public int getThunderDuration() {
        			return thunderDuration;
			}
                public int thunderDuration;
        
                public long getTicksPerAmbientSpawns() {
        			return ticksPerAmbientSpawns;
			}
                public long ticksPerAmbientSpawns;
        
                public long getTicksPerAnimalSpawns() {
        			return ticksPerAnimalSpawns;
			}
                public long ticksPerAnimalSpawns;
        
                public long getTicksPerMonsterSpawns() {
        			return ticksPerMonsterSpawns;
			}
                public long ticksPerMonsterSpawns;
        
                public long getTicksPerSpawns(SpawnCategory spawnCategory) {
        			/* TODO */
				}
                public long getTicksPerWaterAmbientSpawns() {
        			return ticksPerWaterAmbientSpawns;
			}
                public long ticksPerWaterAmbientSpawns;
        
                public long getTicksPerWaterSpawns() {
        			return ticksPerWaterSpawns;
			}
                public long ticksPerWaterSpawns;
        
                public long getTicksPerWaterUndergroundCreatureSpawns() {
        			return ticksPerWaterUndergroundCreatureSpawns;
			}
                public long ticksPerWaterUndergroundCreatureSpawns;
        
                public long getTime() {
        			return time;
			}
                public long time;
        
                public int getViewDistance() {
        			return viewDistance;
			}
                public int viewDistance;
        
                public int getWaterAmbientSpawnLimit() {
        			return waterAmbientSpawnLimit;
			}
                public int waterAmbientSpawnLimit;
        
                public int getWaterAnimalSpawnLimit() {
        			return waterAnimalSpawnLimit;
			}
                public int waterAnimalSpawnLimit;
        
                public int getWaterUndergroundCreatureSpawnLimit() {
        			return waterUndergroundCreatureSpawnLimit;
			}
                public int waterUndergroundCreatureSpawnLimit;
        
                public int getWeatherDuration() {
        			return weatherDuration;
			}
                public int weatherDuration;
        
				@NotNull
                public WorldBorder getWorldBorder() {
        			return worldBorder;
			}
                public WorldBorder worldBorder;
        
				@NotNull
                public File getWorldFolder() {
        			return worldFolder;
			}
                public File worldFolder;
        
				@Nullable
                public WorldType getWorldType() {
        			return worldType;
			}
                public WorldType worldType;
        
                public boolean hasCeiling() {
        			return ceiling;
			}
                public boolean ceiling;
        
                public boolean hasRaids() {
        			return raids;
			}
                public boolean hasSkyLight() {
        			return skyLight;
			}
                public boolean skyLight;
        
                public boolean hasStorm() {
        			return storm;
			}
                public boolean storm;
        
                public boolean isAutoSave() {
        			return autoSave;
			}
                public boolean autoSave;
        
                public boolean isBedWorks() {
        			return bedWorks;
			}
                public boolean bedWorks;
        
                public boolean isChunkForceLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkGenerated(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkInUse(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(Chunk chunk) {
        			/* TODO */
				}
                public boolean isClearWeather() {
        			return clearWeather;
			}
                public boolean clearWeather;
        
                public boolean isGameRule(String rule) {
        			/* TODO */
				}
                public boolean isHardcore() {
        			return hardcore;
			}
                public boolean hardcore;
        
                public boolean isNatural() {
        			return natural;
			}
                public boolean natural;
        
                public boolean isPiglinSafe() {
        			return piglinSafe;
			}
                public boolean piglinSafe;
        
                public boolean isRespawnAnchorWorks() {
        			return respawnAnchorWorks;
			}
                public boolean respawnAnchorWorks;
        
                public boolean isThundering() {
        			return thundering;
			}
                public boolean thundering;
        
                public boolean isUltraWarm() {
        			return ultraWarm;
			}
                public boolean ultraWarm;
        
                public void loadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean loadChunk(int x, int z, boolean generate) {
        			/* TODO */
				}
                public void loadChunk(Chunk chunk) {
        			/* TODO */
				}
				@Nullable
                public Raid locateNearestRaid(Location location, int radius) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, Structure structure, int radius, boolean findUnexplored) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, StructureType structureType, int radius, boolean findUnexplored) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data, int radius) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data, int radius) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, Predicate<Entity> filter) {
        			/* TODO */
				}
                public boolean refreshChunk(int x, int z) {
        			/* TODO */
				}
                public boolean regenerateChunk(int x, int z) {
        			/* TODO */
				}
                public boolean removePluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public void removePluginChunkTickets(Plugin plugin) {
        			/* TODO */
				}
                public void save() {
        			/* TODO */
				}
                public void setAmbientSpawnLimit(int limit) {
        			ambientSpawnLimit = limit;
                }
                
                public void setAnimalSpawnLimit(int limit) {
        			animalSpawnLimit = limit;
                }
                
                public void setAutoSave(boolean value) {
        			autoSave = value;
                }
                
                public void setBiome(int x, int z, Biome bio) {
        			/* TODO */
				}
                public void setChunkForceLoaded(int x, int z, boolean forced) {
        			/* TODO */
				}
                public void setClearWeatherDuration(int duration) {
        			clearWeatherDuration = duration;
                }
                
                public void setDifficulty(Difficulty difficulty) {
        			difficulty = difficulty;
                }
                
                public void setFullTime(long time) {
        			fullTime = time;
                }
                
                public <T> boolean setGameRule(GameRule<T> rule, T newValue) {
        			/* TODO */
				}
                public boolean setGameRuleValue(String rule, String value) {
        			/* TODO */
				}
                public void setHardcore(boolean hardcore) {
        			hardcore = hardcore;
                }
                
                public void setKeepSpawnInMemory(boolean keepLoaded) {
        			keepSpawnInMemory = keepLoaded;
                }
                
                public void setMonsterSpawnLimit(int limit) {
        			monsterSpawnLimit = limit;
                }
                
                public void setPVP(boolean pvp) {
        			pVP = pvp;
                }
                
                public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals) {
        			/* TODO */
				}
                public void setSpawnLimit(SpawnCategory spawnCategory, int limit) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z, float angle) {
        			/* TODO */
				}
                public boolean setSpawnLocation(Location location) {
        			spawnLocation = location;
                }
                
                public void setStorm(boolean hasStorm) {
        			storm = hasStorm;
                }
                
                public void setThunderDuration(int duration) {
        			thunderDuration = duration;
                }
                
                public void setThundering(boolean thundering) {
        			thundering = thundering;
                }
                
                public void setTicksPerAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
        			ticksPerAnimalSpawns = ticksPerAnimalSpawns;
                }
                
                public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
        			ticksPerMonsterSpawns = ticksPerMonsterSpawns;
                }
                
                public void setTicksPerSpawns(SpawnCategory spawnCategory, int ticksPerCategorySpawn) {
        			/* TODO */
				}
                public void setTicksPerWaterAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerWaterAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerWaterSpawns(int ticksPerWaterSpawns) {
        			ticksPerWaterSpawns = ticksPerWaterSpawns;
                }
                
                public void setTicksPerWaterUndergroundCreatureSpawns(int ticksPerWaterUndergroundCreatureSpawns) {
        			ticksPerWaterUndergroundCreatureSpawns = ticksPerWaterUndergroundCreatureSpawns;
                }
                
                public void setTime(long time) {
        			time = time;
                }
                
                public void setWaterAmbientSpawnLimit(int limit) {
        			waterAmbientSpawnLimit = limit;
                }
                
                public void setWaterAnimalSpawnLimit(int limit) {
        			waterAnimalSpawnLimit = limit;
                }
                
                public void setWaterUndergroundCreatureSpawnLimit(int limit) {
        			waterUndergroundCreatureSpawnLimit = limit;
                }
                
                public void setWeatherDuration(int duration) {
        			weatherDuration = duration;
                }
                
				@NotNull
                public Arrow spawnArrow(Location location, Vector direction, float speed, float spread) {
        			/* TODO */
				}
				@NotNull
                <T extends spawnArrow(Location location, Vector direction, float speed, float spread, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, BlockData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, MaterialData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, Material material, byte data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, T data) {
        			/* TODO */
				}
				@NotNull
                public World.Spigot spigot() {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightning(Location loc) {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightningEffect(Location loc) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z, boolean save) {
        			/* TODO */
				}
                public boolean unloadChunk(Chunk chunk) {
        			/* TODO */
				}
                public boolean unloadChunkRequest(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public NamespacedKey getKey() {
        			return key;
			}
                public NamespacedKey key;
        
				@NotNull
                public List<MetadataValue> getMetadata(String metadataKey) {
        			/* TODO */
				}
                public boolean hasMetadata(String metadataKey) {
        			/* TODO */
				}
                public void removeMetadata(String metadataKey, Plugin owningPlugin) {
        			/* TODO */
				}
                public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
        			/* TODO */
				}
				@NotNull
                public PersistentDataContainer getPersistentDataContainer() {
        			return persistentDataContainer;
			}
                public PersistentDataContainer persistentDataContainer;
        
				@NotNull
                public Set<String> getListeningPluginChannels() {
        			return listeningPluginChannels;
			}
                public Set<String> listeningPluginChannels;
        
                public void sendPluginMessage(Plugin source, String channel, byte[] message) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Predicate<BlockState> statePredicate) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Consumer<BlockState> stateConsumer) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(Location location) {
        			/* TODO */
				}
				@NotNull
                public Material getType(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Material getType(Location location) {
        			/* TODO */
				}
                public void setBiome(int x, int y, int z, Biome biome) {
        			/* TODO */
				}
                public void setBiome(Location location, Biome biome) {
        			/* TODO */
				}
                public void setBlockData(int x, int y, int z, BlockData blockData) {
        			/* TODO */
				}
                public void setBlockData(Location location, BlockData blockData) {
        			/* TODO */
				}
                public void setType(int x, int y, int z, Material material) {
        			/* TODO */
				}
                public void setType(Location location, Material material) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, boolean randomizeData, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location location, EntityType type) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location loc, EntityType type, boolean randomizeData) {
        			/* TODO */
				}
				@NotNull
                public World.Environment getEnvironment() {
        			return environment;
			}
                public World.Environment environment;
        
                public int getMaxHeight() {
        			return maxHeight;
			}
                public int maxHeight;
        
                public int getMinHeight() {
        			return minHeight;
			}
                public int minHeight;
        
				@NotNull
                public String getName() {
        			return name;
			}
                public String name;
        
                public long getSeed() {
        			return seed;
			}
                public long seed;
        
				@NotNull
                public UUID getUID() {
        			return uID;
			}
                public UUID uID;
        
            };
            return obj;
        }
    
        org.bukkit.Raid constructRaid(String json) {
            Raid obj = new Raid() {
            
                public long getActiveTicks() {
        			return activeTicks;
			}
                public long activeTicks;
        
                public int getBadOmenLevel() {
        			return badOmenLevel;
			}
                public int badOmenLevel;
        
				@NotNull
                public Set<UUID> getHeroes() {
        			return heroes;
			}
                public Set<UUID> heroes;
        
				@NotNull
                public Location getLocation() {
        			return location;
			}
                public Location location;
        
				@NotNull
                public List<Raider> getRaiders() {
        			return raiders;
			}
                public List<Raider> raiders;
        
                public int getSpawnedGroups() {
        			return spawnedGroups;
			}
                public int spawnedGroups;
        
				@NotNull
                public Raid.RaidStatus getStatus() {
        			return status;
			}
                public Raid.RaidStatus status;
        
                public int getTotalGroups() {
        			return totalGroups;
			}
                public int totalGroups;
        
                public float getTotalHealth() {
        			return totalHealth;
			}
                public float totalHealth;
        
                public int getTotalWaves() {
        			return totalWaves;
			}
                public int totalWaves;
        
                public boolean isStarted() {
        			return started;
			}
                public boolean started;
        
                public void setBadOmenLevel(int badOmenLevel) {
        			badOmenLevel = badOmenLevel;
                }
                
            };
            return obj;
        }
    
        org.bukkit.RegionAccessor constructRegionAccessor(String json) {
            RegionAccessor obj = new RegionAccessor() {
            
                public boolean generateTree(Location location, Random random, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Predicate<BlockState> statePredicate) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Consumer<BlockState> stateConsumer) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(Location location) {
        			/* TODO */
				}
				@NotNull
                public List<Entity> getEntities() {
        			return entities;
			}
                public List<Entity> entities;
        
				@NotNull
                <T extends getEntitiesByClass(Class<T> cls) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
        			/* TODO */
				}
				@NotNull
                public List<LivingEntity> getLivingEntities() {
        			return livingEntities;
			}
                public List<LivingEntity> livingEntities;
        
				@NotNull
                public Material getType(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Material getType(Location location) {
        			/* TODO */
				}
                public void setBiome(int x, int y, int z, Biome biome) {
        			/* TODO */
				}
                public void setBiome(Location location, Biome biome) {
        			/* TODO */
				}
                public void setBlockData(int x, int y, int z, BlockData blockData) {
        			/* TODO */
				}
                public void setBlockData(Location location, BlockData blockData) {
        			/* TODO */
				}
                public void setType(int x, int y, int z, Material material) {
        			/* TODO */
				}
                public void setType(Location location, Material material) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, boolean randomizeData, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location location, EntityType type) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location loc, EntityType type, boolean randomizeData) {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.World constructWorld(String json) {
            World obj = new World() {
            
                public boolean addPluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public boolean canGenerateStructures() {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
                public boolean generateTree(Location location, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
        			/* TODO */
				}
                public boolean getAllowAnimals() {
        			return allowAnimals;
			}
                public boolean allowAnimals;
        
                public boolean getAllowMonsters() {
        			return allowMonsters;
			}
                public boolean allowMonsters;
        
                public int getAmbientSpawnLimit() {
        			return ambientSpawnLimit;
			}
                public int ambientSpawnLimit;
        
                public int getAnimalSpawnLimit() {
        			return animalSpawnLimit;
			}
                public int animalSpawnLimit;
        
				@NotNull
                public Biome getBiome(int x, int z) {
        			/* TODO */
				}
				@Nullable
                public BiomeProvider getBiomeProvider() {
        			return biomeProvider;
			}
                public BiomeProvider biomeProvider;
        
				@NotNull
                public Block getBlockAt(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Block block) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Location location) {
        			/* TODO */
				}
                public int getClearWeatherDuration() {
        			return clearWeatherDuration;
			}
                public int clearWeatherDuration;
        
				@NotNull
                public Difficulty getDifficulty() {
        			return difficulty;
			}
                public Difficulty difficulty;
        
				@NotNull
                public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTemp) {
        			/* TODO */
				}
				@Nullable
                public DragonBattle getEnderDragonBattle() {
        			return enderDragonBattle;
			}
                public DragonBattle enderDragonBattle;
        
				@NotNull
                public List<Entity> getEntities() {
        			return entities;
			}
                public List<Entity> entities;
        
				@NotNull
                <T extends getEntitiesByClass(Class<T> cls) {
        			/* TODO */
				}
				@NotNull
                <T extends getEntitiesByClass(Class<T>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Chunk> getForceLoadedChunks() {
        			return forceLoadedChunks;
			}
                public Collection<Chunk> forceLoadedChunks;
        
                public long getFullTime() {
        			return fullTime;
			}
                public long fullTime;
        
				@Nullable
                public <T> T getGameRuleDefault(GameRule<T> rule) {
        			/* TODO */
				}
				@NotNull
                public String[] getGameRules() {
        			return gameRules;
			}
                public String[] gameRules;
        
				@Nullable
                public String getGameRuleValue(String rule) {
        			/* TODO */
				}
				@Nullable
                public <T> T getGameRuleValue(GameRule<T> rule) {
        			/* TODO */
				}
                public long getGameTime() {
        			return gameTime;
			}
                public long gameTime;
        
				@Nullable
                public ChunkGenerator getGenerator() {
        			return generator;
			}
                public ChunkGenerator generator;
        
				@NotNull
                public Block getHighestBlockAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public double getHumidity(int x, int z) {
        			/* TODO */
				}
                public double getHumidity(int x, int y, int z) {
        			/* TODO */
				}
                public boolean getKeepSpawnInMemory() {
        			return keepSpawnInMemory;
			}
                public boolean keepSpawnInMemory;
        
				@NotNull
                public List<LivingEntity> getLivingEntities() {
        			return livingEntities;
			}
                public List<LivingEntity> livingEntities;
        
				@NotNull
                public Chunk[] getLoadedChunks() {
        			return loadedChunks;
			}
                public Chunk[] loadedChunks;
        
                public int getLogicalHeight() {
        			return logicalHeight;
			}
                public int logicalHeight;
        
                public int getMonsterSpawnLimit() {
        			return monsterSpawnLimit;
			}
                public int monsterSpawnLimit;
        
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public List<Player> getPlayers() {
        			return players;
			}
                public List<Player> players;
        
				@NotNull
                public Map<Plugin,Collection<Chunk>> getPluginChunkTickets() {
        			return pluginChunkTickets;
			}
                public Map<Plugin,Collection<Chunk>> pluginChunkTickets;
        
				@NotNull
                public Collection<Plugin> getPluginChunkTickets(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public List<BlockPopulator> getPopulators() {
        			return populators;
			}
                public List<BlockPopulator> populators;
        
                public boolean getPVP() {
        			return pVP;
			}
                public boolean pVP;
        
				@NotNull
                public List<Raid> getRaids() {
        			return raids;
			}
                public List<Raid> raids;
        
                public int getSeaLevel() {
        			return seaLevel;
			}
                public int seaLevel;
        
                public int getSimulationDistance() {
        			return simulationDistance;
			}
                public int simulationDistance;
        
                public int getSpawnLimit(SpawnCategory spawnCategory) {
        			/* TODO */
				}
				@NotNull
                public Location getSpawnLocation() {
        			return spawnLocation;
			}
                public Location spawnLocation;
        
                public double getTemperature(int x, int z) {
        			/* TODO */
				}
                public double getTemperature(int x, int y, int z) {
        			/* TODO */
				}
                public int getThunderDuration() {
        			return thunderDuration;
			}
                public int thunderDuration;
        
                public long getTicksPerAmbientSpawns() {
        			return ticksPerAmbientSpawns;
			}
                public long ticksPerAmbientSpawns;
        
                public long getTicksPerAnimalSpawns() {
        			return ticksPerAnimalSpawns;
			}
                public long ticksPerAnimalSpawns;
        
                public long getTicksPerMonsterSpawns() {
        			return ticksPerMonsterSpawns;
			}
                public long ticksPerMonsterSpawns;
        
                public long getTicksPerSpawns(SpawnCategory spawnCategory) {
        			/* TODO */
				}
                public long getTicksPerWaterAmbientSpawns() {
        			return ticksPerWaterAmbientSpawns;
			}
                public long ticksPerWaterAmbientSpawns;
        
                public long getTicksPerWaterSpawns() {
        			return ticksPerWaterSpawns;
			}
                public long ticksPerWaterSpawns;
        
                public long getTicksPerWaterUndergroundCreatureSpawns() {
        			return ticksPerWaterUndergroundCreatureSpawns;
			}
                public long ticksPerWaterUndergroundCreatureSpawns;
        
                public long getTime() {
        			return time;
			}
                public long time;
        
                public int getViewDistance() {
        			return viewDistance;
			}
                public int viewDistance;
        
                public int getWaterAmbientSpawnLimit() {
        			return waterAmbientSpawnLimit;
			}
                public int waterAmbientSpawnLimit;
        
                public int getWaterAnimalSpawnLimit() {
        			return waterAnimalSpawnLimit;
			}
                public int waterAnimalSpawnLimit;
        
                public int getWaterUndergroundCreatureSpawnLimit() {
        			return waterUndergroundCreatureSpawnLimit;
			}
                public int waterUndergroundCreatureSpawnLimit;
        
                public int getWeatherDuration() {
        			return weatherDuration;
			}
                public int weatherDuration;
        
				@NotNull
                public WorldBorder getWorldBorder() {
        			return worldBorder;
			}
                public WorldBorder worldBorder;
        
				@NotNull
                public File getWorldFolder() {
        			return worldFolder;
			}
                public File worldFolder;
        
				@Nullable
                public WorldType getWorldType() {
        			return worldType;
			}
                public WorldType worldType;
        
                public boolean hasCeiling() {
        			return ceiling;
			}
                public boolean ceiling;
        
                public boolean hasRaids() {
        			return raids;
			}
                public boolean hasSkyLight() {
        			return skyLight;
			}
                public boolean skyLight;
        
                public boolean hasStorm() {
        			return storm;
			}
                public boolean storm;
        
                public boolean isAutoSave() {
        			return autoSave;
			}
                public boolean autoSave;
        
                public boolean isBedWorks() {
        			return bedWorks;
			}
                public boolean bedWorks;
        
                public boolean isChunkForceLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkGenerated(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkInUse(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(Chunk chunk) {
        			/* TODO */
				}
                public boolean isClearWeather() {
        			return clearWeather;
			}
                public boolean clearWeather;
        
                public boolean isGameRule(String rule) {
        			/* TODO */
				}
                public boolean isHardcore() {
        			return hardcore;
			}
                public boolean hardcore;
        
                public boolean isNatural() {
        			return natural;
			}
                public boolean natural;
        
                public boolean isPiglinSafe() {
        			return piglinSafe;
			}
                public boolean piglinSafe;
        
                public boolean isRespawnAnchorWorks() {
        			return respawnAnchorWorks;
			}
                public boolean respawnAnchorWorks;
        
                public boolean isThundering() {
        			return thundering;
			}
                public boolean thundering;
        
                public boolean isUltraWarm() {
        			return ultraWarm;
			}
                public boolean ultraWarm;
        
                public void loadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean loadChunk(int x, int z, boolean generate) {
        			/* TODO */
				}
                public void loadChunk(Chunk chunk) {
        			/* TODO */
				}
				@Nullable
                public Raid locateNearestRaid(Location location, int radius) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, Structure structure, int radius, boolean findUnexplored) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, StructureType structureType, int radius, boolean findUnexplored) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data, int radius) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data, int radius) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, Predicate<Entity> filter) {
        			/* TODO */
				}
                public boolean refreshChunk(int x, int z) {
        			/* TODO */
				}
                public boolean regenerateChunk(int x, int z) {
        			/* TODO */
				}
                public boolean removePluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public void removePluginChunkTickets(Plugin plugin) {
        			/* TODO */
				}
                public void save() {
        			/* TODO */
				}
                public void setAmbientSpawnLimit(int limit) {
        			ambientSpawnLimit = limit;
                }
                
                public void setAnimalSpawnLimit(int limit) {
        			animalSpawnLimit = limit;
                }
                
                public void setAutoSave(boolean value) {
        			autoSave = value;
                }
                
                public void setBiome(int x, int z, Biome bio) {
        			/* TODO */
				}
                public void setChunkForceLoaded(int x, int z, boolean forced) {
        			/* TODO */
				}
                public void setClearWeatherDuration(int duration) {
        			clearWeatherDuration = duration;
                }
                
                public void setDifficulty(Difficulty difficulty) {
        			difficulty = difficulty;
                }
                
                public void setFullTime(long time) {
        			fullTime = time;
                }
                
                public <T> boolean setGameRule(GameRule<T> rule, T newValue) {
        			/* TODO */
				}
                public boolean setGameRuleValue(String rule, String value) {
        			/* TODO */
				}
                public void setHardcore(boolean hardcore) {
        			hardcore = hardcore;
                }
                
                public void setKeepSpawnInMemory(boolean keepLoaded) {
        			keepSpawnInMemory = keepLoaded;
                }
                
                public void setMonsterSpawnLimit(int limit) {
        			monsterSpawnLimit = limit;
                }
                
                public void setPVP(boolean pvp) {
        			pVP = pvp;
                }
                
                public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals) {
        			/* TODO */
				}
                public void setSpawnLimit(SpawnCategory spawnCategory, int limit) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z, float angle) {
        			/* TODO */
				}
                public boolean setSpawnLocation(Location location) {
        			spawnLocation = location;
                }
                
                public void setStorm(boolean hasStorm) {
        			storm = hasStorm;
                }
                
                public void setThunderDuration(int duration) {
        			thunderDuration = duration;
                }
                
                public void setThundering(boolean thundering) {
        			thundering = thundering;
                }
                
                public void setTicksPerAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
        			ticksPerAnimalSpawns = ticksPerAnimalSpawns;
                }
                
                public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
        			ticksPerMonsterSpawns = ticksPerMonsterSpawns;
                }
                
                public void setTicksPerSpawns(SpawnCategory spawnCategory, int ticksPerCategorySpawn) {
        			/* TODO */
				}
                public void setTicksPerWaterAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerWaterAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerWaterSpawns(int ticksPerWaterSpawns) {
        			ticksPerWaterSpawns = ticksPerWaterSpawns;
                }
                
                public void setTicksPerWaterUndergroundCreatureSpawns(int ticksPerWaterUndergroundCreatureSpawns) {
        			ticksPerWaterUndergroundCreatureSpawns = ticksPerWaterUndergroundCreatureSpawns;
                }
                
                public void setTime(long time) {
        			time = time;
                }
                
                public void setWaterAmbientSpawnLimit(int limit) {
        			waterAmbientSpawnLimit = limit;
                }
                
                public void setWaterAnimalSpawnLimit(int limit) {
        			waterAnimalSpawnLimit = limit;
                }
                
                public void setWaterUndergroundCreatureSpawnLimit(int limit) {
        			waterUndergroundCreatureSpawnLimit = limit;
                }
                
                public void setWeatherDuration(int duration) {
        			weatherDuration = duration;
                }
                
				@NotNull
                public Arrow spawnArrow(Location location, Vector direction, float speed, float spread) {
        			/* TODO */
				}
				@NotNull
                <T extends spawnArrow(Location location, Vector direction, float speed, float spread, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, BlockData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, MaterialData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, Material material, byte data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, T data) {
        			/* TODO */
				}
				@NotNull
                public World.Spigot spigot() {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightning(Location loc) {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightningEffect(Location loc) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z, boolean save) {
        			/* TODO */
				}
                public boolean unloadChunk(Chunk chunk) {
        			/* TODO */
				}
                public boolean unloadChunkRequest(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public NamespacedKey getKey() {
        			return key;
			}
                public NamespacedKey key;
        
				@NotNull
                public List<MetadataValue> getMetadata(String metadataKey) {
        			/* TODO */
				}
                public boolean hasMetadata(String metadataKey) {
        			/* TODO */
				}
                public void removeMetadata(String metadataKey, Plugin owningPlugin) {
        			/* TODO */
				}
                public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
        			/* TODO */
				}
				@NotNull
                public PersistentDataContainer getPersistentDataContainer() {
        			return persistentDataContainer;
			}
                public PersistentDataContainer persistentDataContainer;
        
				@NotNull
                public Set<String> getListeningPluginChannels() {
        			return listeningPluginChannels;
			}
                public Set<String> listeningPluginChannels;
        
                public void sendPluginMessage(Plugin source, String channel, byte[] message) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Predicate<BlockState> statePredicate) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Consumer<BlockState> stateConsumer) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(Location location) {
        			/* TODO */
				}
				@NotNull
                public Material getType(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Material getType(Location location) {
        			/* TODO */
				}
                public void setBiome(int x, int y, int z, Biome biome) {
        			/* TODO */
				}
                public void setBiome(Location location, Biome biome) {
        			/* TODO */
				}
                public void setBlockData(int x, int y, int z, BlockData blockData) {
        			/* TODO */
				}
                public void setBlockData(Location location, BlockData blockData) {
        			/* TODO */
				}
                public void setType(int x, int y, int z, Material material) {
        			/* TODO */
				}
                public void setType(Location location, Material material) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, boolean randomizeData, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location location, EntityType type) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location loc, EntityType type, boolean randomizeData) {
        			/* TODO */
				}
				@NotNull
                public World.Environment getEnvironment() {
        			return environment;
			}
                public World.Environment environment;
        
                public int getMaxHeight() {
        			return maxHeight;
			}
                public int maxHeight;
        
                public int getMinHeight() {
        			return minHeight;
			}
                public int minHeight;
        
				@NotNull
                public String getName() {
        			return name;
			}
                public String name;
        
                public long getSeed() {
        			return seed;
			}
                public long seed;
        
				@NotNull
                public UUID getUID() {
        			return uID;
			}
                public UUID uID;
        
            };
            return obj;
        }
    
        org.bukkit.permissions.ServerOperator constructServerOperator(String json) {
            ServerOperator obj = new ServerOperator() {
            
                public boolean isOp() {
        			return op;
			}
                public boolean op;
        
                public void setOp(boolean value) {
        			op = value;
                }
                
            };
            return obj;
        }
    
        org.bukkit.OfflinePlayer constructOfflinePlayer(String json) {
            OfflinePlayer obj = new OfflinePlayer() {
            
                public void decrementStatistic(Statistic statistic) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, int amount) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, EntityType entityType) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, EntityType entityType, int amount) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, Material material) {
        			/* TODO */
				}
                public void decrementStatistic(Statistic statistic, Material material, int amount) {
        			/* TODO */
				}
				@Nullable
                public Location getBedSpawnLocation() {
        			return bedSpawnLocation;
			}
                public Location bedSpawnLocation;
        
                public long getFirstPlayed() {
        			return firstPlayed;
			}
                public long firstPlayed;
        
				@Nullable
                public Location getLastDeathLocation() {
        			return lastDeathLocation;
			}
                public Location lastDeathLocation;
        
                public long getLastPlayed() {
        			return lastPlayed;
			}
                public long lastPlayed;
        
				@Nullable
                public String getName() {
        			return name;
			}
                public String name;
        
				@Nullable
                public Player getPlayer() {
        			return player;
			}
                public Player player;
        
				@NotNull
                public PlayerProfile getPlayerProfile() {
        			return playerProfile;
			}
                public PlayerProfile playerProfile;
        
                public int getStatistic(Statistic statistic) {
        			/* TODO */
				}
                public int getStatistic(Statistic statistic, EntityType entityType) {
        			/* TODO */
				}
                public int getStatistic(Statistic statistic, Material material) {
        			/* TODO */
				}
				@NotNull
                public UUID getUniqueId() {
        			return uniqueId;
			}
                public UUID uniqueId;
        
                public boolean hasPlayedBefore() {
        			return playedBefore;
			}
                public boolean playedBefore;
        
                public void incrementStatistic(Statistic statistic) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, int amount) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, EntityType entityType) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, Material material) {
        			/* TODO */
				}
                public void incrementStatistic(Statistic statistic, Material material, int amount) {
        			/* TODO */
				}
                public boolean isBanned() {
        			return banned;
			}
                public boolean banned;
        
                public boolean isOnline() {
        			return online;
			}
                public boolean online;
        
                public boolean isWhitelisted() {
        			return whitelisted;
			}
                public boolean whitelisted;
        
                public void setStatistic(Statistic statistic, int newValue) {
        			/* TODO */
				}
                public void setStatistic(Statistic statistic, EntityType entityType, int newValue) {
        			/* TODO */
				}
                public void setStatistic(Statistic statistic, Material material, int newValue) {
        			/* TODO */
				}
                public void setWhitelisted(boolean value) {
        			whitelisted = value;
                }
                
				@NotNull
                public Map<String,Object> serialize() {
        			/* TODO */
				}
                public boolean isOp() {
        			return op;
			}
                public boolean op;
        
                public void setOp(boolean value) {
        			op = value;
                }
                
            };
            return obj;
        }
    
        org.bukkit.SoundGroup constructSoundGroup(String json) {
            SoundGroup obj = new SoundGroup() {
            
				@NotNull
                public Sound getBreakSound() {
        			return breakSound;
			}
                public Sound breakSound;
        
				@NotNull
                public Sound getFallSound() {
        			return fallSound;
			}
                public Sound fallSound;
        
				@NotNull
                public Sound getHitSound() {
        			return hitSound;
			}
                public Sound hitSound;
        
                public float getPitch() {
        			return pitch;
			}
                public float pitch;
        
				@NotNull
                public Sound getPlaceSound() {
        			return placeSound;
			}
                public Sound placeSound;
        
				@NotNull
                public Sound getStepSound() {
        			return stepSound;
			}
                public Sound stepSound;
        
                public float getVolume() {
        			return volume;
			}
                public float volume;
        
            };
            return obj;
        }
    
        org.bukkit.UnsafeValues constructUnsafeValues(String json) {
            UnsafeValues obj = new UnsafeValues() {
            
                public void checkSupported(PluginDescriptionFile pdf) {
        			/* TODO */
				}
                public Material fromLegacy(Material material) {
        			/* TODO */
				}
                public Material fromLegacy(MaterialData material) {
        			/* TODO */
				}
                public Material fromLegacy(MaterialData material, boolean itemPriority) {
        			/* TODO */
				}
                public BlockData fromLegacy(Material material, byte data) {
        			/* TODO */
				}
                public CreativeCategory getCreativeCategory(Material material) {
        			/* TODO */
				}
                public int getDataVersion() {
        			return dataVersion;
			}
                public int dataVersion;
        
                public Multimap<Attribute,AttributeModifier> getDefaultAttributeModifiers(Material material, EquipmentSlot slot) {
        			/* TODO */
				}
                public Material getMaterial(String material, int version) {
        			/* TODO */
				}
                public Advancement loadAdvancement(NamespacedKey key, String advancement) {
        			/* TODO */
				}
                public ItemStack modifyItemStack(ItemStack stack, String arguments) {
        			/* TODO */
				}
                public byte[] processClass(PluginDescriptionFile pdf, String path, byte[] clazz) {
        			/* TODO */
				}
                public boolean removeAdvancement(NamespacedKey key) {
        			/* TODO */
				}
                public Material toLegacy(Material material) {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.Vibration.Destination constructDestination(String json) {
            Destination obj = new Destination() {
            
                static class  Vibration.Destination.BlockDestination() {
        			/* TODO */
				}
                static class  Vibration.Destination.EntityDestination() {
        			/* TODO */
				}
            };
            return obj;
        }
    
        org.bukkit.WorldBorder constructWorldBorder(String json) {
            WorldBorder obj = new WorldBorder() {
            
				@NotNull
                public Location getCenter() {
        			return center;
			}
                public Location center;
        
                public double getDamageAmount() {
        			return damageAmount;
			}
                public double damageAmount;
        
                public double getDamageBuffer() {
        			return damageBuffer;
			}
                public double damageBuffer;
        
                public double getMaxCenterCoordinate() {
        			return maxCenterCoordinate;
			}
                public double maxCenterCoordinate;
        
                public double getMaxSize() {
        			return maxSize;
			}
                public double maxSize;
        
                public double getSize() {
        			return size;
			}
                public double size;
        
                public int getWarningDistance() {
        			return warningDistance;
			}
                public int warningDistance;
        
                public int getWarningTime() {
        			return warningTime;
			}
                public int warningTime;
        
				@Nullable
                public World getWorld() {
        			return world;
			}
                public World world;
        
                public boolean isInside(Location location) {
        			/* TODO */
				}
                public void reset() {
        			/* TODO */
				}
                public void setCenter(double x, double z) {
        			/* TODO */
				}
                public void setCenter(Location location) {
        			center = location;
                }
                
                public void setDamageAmount(double damage) {
        			damageAmount = damage;
                }
                
                public void setDamageBuffer(double blocks) {
        			damageBuffer = blocks;
                }
                
                public void setSize(double newSize) {
        			size = newSize;
                }
                
                public void setSize(double newSize, long seconds) {
        			/* TODO */
				}
                public void setSize(double newSize, TimeUnit unit, long time) {
        			/* TODO */
				}
                public void setWarningDistance(int distance) {
        			warningDistance = distance;
                }
                
                public void setWarningTime(int seconds) {
        			warningTime = seconds;
                }
                
            };
            return obj;
        }
    
        org.bukkit.generator.WorldInfo constructWorldInfo(String json) {
            WorldInfo obj = new WorldInfo() {
            
				@NotNull
                public World.Environment getEnvironment() {
        			return environment;
			}
                public World.Environment environment;
        
                public int getMaxHeight() {
        			return maxHeight;
			}
                public int maxHeight;
        
                public int getMinHeight() {
        			return minHeight;
			}
                public int minHeight;
        
				@NotNull
                public String getName() {
        			return name;
			}
                public String name;
        
                public long getSeed() {
        			return seed;
			}
                public long seed;
        
				@NotNull
                public UUID getUID() {
        			return uID;
			}
                public UUID uID;
        
            };
            return obj;
        }
    
        org.bukkit.World constructWorld(String json) {
            World obj = new World() {
            
                public boolean addPluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public boolean canGenerateStructures() {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks) {
        			/* TODO */
				}
                public boolean createExplosion(Location loc, float power, boolean setFire, boolean breakBlocks, Entity source) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItem(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item) {
        			/* TODO */
				}
				@NotNull
                public Item dropItemNaturally(Location location, ItemStack item, Consumer<Item> function) {
        			/* TODO */
				}
                public boolean generateTree(Location location, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
        			/* TODO */
				}
                public boolean getAllowAnimals() {
        			return allowAnimals;
			}
                public boolean allowAnimals;
        
                public boolean getAllowMonsters() {
        			return allowMonsters;
			}
                public boolean allowMonsters;
        
                public int getAmbientSpawnLimit() {
        			return ambientSpawnLimit;
			}
                public int ambientSpawnLimit;
        
                public int getAnimalSpawnLimit() {
        			return animalSpawnLimit;
			}
                public int animalSpawnLimit;
        
				@NotNull
                public Biome getBiome(int x, int z) {
        			/* TODO */
				}
				@Nullable
                public BiomeProvider getBiomeProvider() {
        			return biomeProvider;
			}
                public BiomeProvider biomeProvider;
        
				@NotNull
                public Block getBlockAt(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Block block) {
        			/* TODO */
				}
				@NotNull
                public Chunk getChunkAt(Location location) {
        			/* TODO */
				}
                public int getClearWeatherDuration() {
        			return clearWeatherDuration;
			}
                public int clearWeatherDuration;
        
				@NotNull
                public Difficulty getDifficulty() {
        			return difficulty;
			}
                public Difficulty difficulty;
        
				@NotNull
                public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTemp) {
        			/* TODO */
				}
				@Nullable
                public DragonBattle getEnderDragonBattle() {
        			return enderDragonBattle;
			}
                public DragonBattle enderDragonBattle;
        
				@NotNull
                public List<Entity> getEntities() {
        			return entities;
			}
                public List<Entity> entities;
        
				@NotNull
                <T extends getEntitiesByClass(Class<T> cls) {
        			/* TODO */
				}
				@NotNull
                <T extends getEntitiesByClass(Class<T>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
        			/* TODO */
				}
				@NotNull
                public Collection<Chunk> getForceLoadedChunks() {
        			return forceLoadedChunks;
			}
                public Collection<Chunk> forceLoadedChunks;
        
                public long getFullTime() {
        			return fullTime;
			}
                public long fullTime;
        
				@Nullable
                public <T> T getGameRuleDefault(GameRule<T> rule) {
        			/* TODO */
				}
				@NotNull
                public String[] getGameRules() {
        			return gameRules;
			}
                public String[] gameRules;
        
				@Nullable
                public String getGameRuleValue(String rule) {
        			/* TODO */
				}
				@Nullable
                public <T> T getGameRuleValue(GameRule<T> rule) {
        			/* TODO */
				}
                public long getGameTime() {
        			return gameTime;
			}
                public long gameTime;
        
				@Nullable
                public ChunkGenerator getGenerator() {
        			return generator;
			}
                public ChunkGenerator generator;
        
				@NotNull
                public Block getHighestBlockAt(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location) {
        			/* TODO */
				}
				@NotNull
                public Block getHighestBlockAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z) {
        			/* TODO */
				}
                public int getHighestBlockYAt(int x, int z, HeightMap heightMap) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location) {
        			/* TODO */
				}
                public int getHighestBlockYAt(Location location, HeightMap heightMap) {
        			/* TODO */
				}
                public double getHumidity(int x, int z) {
        			/* TODO */
				}
                public double getHumidity(int x, int y, int z) {
        			/* TODO */
				}
                public boolean getKeepSpawnInMemory() {
        			return keepSpawnInMemory;
			}
                public boolean keepSpawnInMemory;
        
				@NotNull
                public List<LivingEntity> getLivingEntities() {
        			return livingEntities;
			}
                public List<LivingEntity> livingEntities;
        
				@NotNull
                public Chunk[] getLoadedChunks() {
        			return loadedChunks;
			}
                public Chunk[] loadedChunks;
        
                public int getLogicalHeight() {
        			return logicalHeight;
			}
                public int logicalHeight;
        
                public int getMonsterSpawnLimit() {
        			return monsterSpawnLimit;
			}
                public int monsterSpawnLimit;
        
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox) {
        			/* TODO */
				}
				@NotNull
                public Collection<Entity> getNearbyEntities(BoundingBox boundingBox, Predicate<Entity> filter) {
        			/* TODO */
				}
				@NotNull
                public List<Player> getPlayers() {
        			return players;
			}
                public List<Player> players;
        
				@NotNull
                public Map<Plugin,Collection<Chunk>> getPluginChunkTickets() {
        			return pluginChunkTickets;
			}
                public Map<Plugin,Collection<Chunk>> pluginChunkTickets;
        
				@NotNull
                public Collection<Plugin> getPluginChunkTickets(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public List<BlockPopulator> getPopulators() {
        			return populators;
			}
                public List<BlockPopulator> populators;
        
                public boolean getPVP() {
        			return pVP;
			}
                public boolean pVP;
        
				@NotNull
                public List<Raid> getRaids() {
        			return raids;
			}
                public List<Raid> raids;
        
                public int getSeaLevel() {
        			return seaLevel;
			}
                public int seaLevel;
        
                public int getSimulationDistance() {
        			return simulationDistance;
			}
                public int simulationDistance;
        
                public int getSpawnLimit(SpawnCategory spawnCategory) {
        			/* TODO */
				}
				@NotNull
                public Location getSpawnLocation() {
        			return spawnLocation;
			}
                public Location spawnLocation;
        
                public double getTemperature(int x, int z) {
        			/* TODO */
				}
                public double getTemperature(int x, int y, int z) {
        			/* TODO */
				}
                public int getThunderDuration() {
        			return thunderDuration;
			}
                public int thunderDuration;
        
                public long getTicksPerAmbientSpawns() {
        			return ticksPerAmbientSpawns;
			}
                public long ticksPerAmbientSpawns;
        
                public long getTicksPerAnimalSpawns() {
        			return ticksPerAnimalSpawns;
			}
                public long ticksPerAnimalSpawns;
        
                public long getTicksPerMonsterSpawns() {
        			return ticksPerMonsterSpawns;
			}
                public long ticksPerMonsterSpawns;
        
                public long getTicksPerSpawns(SpawnCategory spawnCategory) {
        			/* TODO */
				}
                public long getTicksPerWaterAmbientSpawns() {
        			return ticksPerWaterAmbientSpawns;
			}
                public long ticksPerWaterAmbientSpawns;
        
                public long getTicksPerWaterSpawns() {
        			return ticksPerWaterSpawns;
			}
                public long ticksPerWaterSpawns;
        
                public long getTicksPerWaterUndergroundCreatureSpawns() {
        			return ticksPerWaterUndergroundCreatureSpawns;
			}
                public long ticksPerWaterUndergroundCreatureSpawns;
        
                public long getTime() {
        			return time;
			}
                public long time;
        
                public int getViewDistance() {
        			return viewDistance;
			}
                public int viewDistance;
        
                public int getWaterAmbientSpawnLimit() {
        			return waterAmbientSpawnLimit;
			}
                public int waterAmbientSpawnLimit;
        
                public int getWaterAnimalSpawnLimit() {
        			return waterAnimalSpawnLimit;
			}
                public int waterAnimalSpawnLimit;
        
                public int getWaterUndergroundCreatureSpawnLimit() {
        			return waterUndergroundCreatureSpawnLimit;
			}
                public int waterUndergroundCreatureSpawnLimit;
        
                public int getWeatherDuration() {
        			return weatherDuration;
			}
                public int weatherDuration;
        
				@NotNull
                public WorldBorder getWorldBorder() {
        			return worldBorder;
			}
                public WorldBorder worldBorder;
        
				@NotNull
                public File getWorldFolder() {
        			return worldFolder;
			}
                public File worldFolder;
        
				@Nullable
                public WorldType getWorldType() {
        			return worldType;
			}
                public WorldType worldType;
        
                public boolean hasCeiling() {
        			return ceiling;
			}
                public boolean ceiling;
        
                public boolean hasRaids() {
        			return raids;
			}
                public boolean hasSkyLight() {
        			return skyLight;
			}
                public boolean skyLight;
        
                public boolean hasStorm() {
        			return storm;
			}
                public boolean storm;
        
                public boolean isAutoSave() {
        			return autoSave;
			}
                public boolean autoSave;
        
                public boolean isBedWorks() {
        			return bedWorks;
			}
                public boolean bedWorks;
        
                public boolean isChunkForceLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkGenerated(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkInUse(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(int x, int z) {
        			/* TODO */
				}
                public boolean isChunkLoaded(Chunk chunk) {
        			/* TODO */
				}
                public boolean isClearWeather() {
        			return clearWeather;
			}
                public boolean clearWeather;
        
                public boolean isGameRule(String rule) {
        			/* TODO */
				}
                public boolean isHardcore() {
        			return hardcore;
			}
                public boolean hardcore;
        
                public boolean isNatural() {
        			return natural;
			}
                public boolean natural;
        
                public boolean isPiglinSafe() {
        			return piglinSafe;
			}
                public boolean piglinSafe;
        
                public boolean isRespawnAnchorWorks() {
        			return respawnAnchorWorks;
			}
                public boolean respawnAnchorWorks;
        
                public boolean isThundering() {
        			return thundering;
			}
                public boolean thundering;
        
                public boolean isUltraWarm() {
        			return ultraWarm;
			}
                public boolean ultraWarm;
        
                public void loadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean loadChunk(int x, int z, boolean generate) {
        			/* TODO */
				}
                public void loadChunk(Chunk chunk) {
        			/* TODO */
				}
				@Nullable
                public Raid locateNearestRaid(Location location, int radius) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, Structure structure, int radius, boolean findUnexplored) {
        			/* TODO */
				}
				@Nullable
                public StructureSearchResult locateNearestStructure(Location origin, StructureType structureType, int radius, boolean findUnexplored) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data) {
        			/* TODO */
				}
                public void playEffect(Location location, Effect effect, int data, int radius) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data) {
        			/* TODO */
				}
                public <T> void playEffect(Location location, Effect effect, T data, int radius) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Entity entity, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, String sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, float volume, float pitch) {
        			/* TODO */
				}
                public void playSound(Location location, Sound sound, SoundCategory category, float volume, float pitch) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
        			/* TODO */
				}
				@Nullable
                public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, Predicate<Entity> filter) {
        			/* TODO */
				}
                public boolean refreshChunk(int x, int z) {
        			/* TODO */
				}
                public boolean regenerateChunk(int x, int z) {
        			/* TODO */
				}
                public boolean removePluginChunkTicket(int x, int z, Plugin plugin) {
        			/* TODO */
				}
                public void removePluginChunkTickets(Plugin plugin) {
        			/* TODO */
				}
                public void save() {
        			/* TODO */
				}
                public void setAmbientSpawnLimit(int limit) {
        			ambientSpawnLimit = limit;
                }
                
                public void setAnimalSpawnLimit(int limit) {
        			animalSpawnLimit = limit;
                }
                
                public void setAutoSave(boolean value) {
        			autoSave = value;
                }
                
                public void setBiome(int x, int z, Biome bio) {
        			/* TODO */
				}
                public void setChunkForceLoaded(int x, int z, boolean forced) {
        			/* TODO */
				}
                public void setClearWeatherDuration(int duration) {
        			clearWeatherDuration = duration;
                }
                
                public void setDifficulty(Difficulty difficulty) {
        			difficulty = difficulty;
                }
                
                public void setFullTime(long time) {
        			fullTime = time;
                }
                
                public <T> boolean setGameRule(GameRule<T> rule, T newValue) {
        			/* TODO */
				}
                public boolean setGameRuleValue(String rule, String value) {
        			/* TODO */
				}
                public void setHardcore(boolean hardcore) {
        			hardcore = hardcore;
                }
                
                public void setKeepSpawnInMemory(boolean keepLoaded) {
        			keepSpawnInMemory = keepLoaded;
                }
                
                public void setMonsterSpawnLimit(int limit) {
        			monsterSpawnLimit = limit;
                }
                
                public void setPVP(boolean pvp) {
        			pVP = pvp;
                }
                
                public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals) {
        			/* TODO */
				}
                public void setSpawnLimit(SpawnCategory spawnCategory, int limit) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z) {
        			/* TODO */
				}
                public boolean setSpawnLocation(int x, int y, int z, float angle) {
        			/* TODO */
				}
                public boolean setSpawnLocation(Location location) {
        			spawnLocation = location;
                }
                
                public void setStorm(boolean hasStorm) {
        			storm = hasStorm;
                }
                
                public void setThunderDuration(int duration) {
        			thunderDuration = duration;
                }
                
                public void setThundering(boolean thundering) {
        			thundering = thundering;
                }
                
                public void setTicksPerAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
        			ticksPerAnimalSpawns = ticksPerAnimalSpawns;
                }
                
                public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
        			ticksPerMonsterSpawns = ticksPerMonsterSpawns;
                }
                
                public void setTicksPerSpawns(SpawnCategory spawnCategory, int ticksPerCategorySpawn) {
        			/* TODO */
				}
                public void setTicksPerWaterAmbientSpawns(int ticksPerAmbientSpawns) {
        			ticksPerWaterAmbientSpawns = ticksPerAmbientSpawns;
                }
                
                public void setTicksPerWaterSpawns(int ticksPerWaterSpawns) {
        			ticksPerWaterSpawns = ticksPerWaterSpawns;
                }
                
                public void setTicksPerWaterUndergroundCreatureSpawns(int ticksPerWaterUndergroundCreatureSpawns) {
        			ticksPerWaterUndergroundCreatureSpawns = ticksPerWaterUndergroundCreatureSpawns;
                }
                
                public void setTime(long time) {
        			time = time;
                }
                
                public void setWaterAmbientSpawnLimit(int limit) {
        			waterAmbientSpawnLimit = limit;
                }
                
                public void setWaterAnimalSpawnLimit(int limit) {
        			waterAnimalSpawnLimit = limit;
                }
                
                public void setWaterUndergroundCreatureSpawnLimit(int limit) {
        			waterUndergroundCreatureSpawnLimit = limit;
                }
                
                public void setWeatherDuration(int duration) {
        			weatherDuration = duration;
                }
                
				@NotNull
                public Arrow spawnArrow(Location location, Vector direction, float speed, float spread) {
        			/* TODO */
				}
				@NotNull
                <T extends spawnArrow(Location location, Vector direction, float speed, float spread, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, BlockData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, MaterialData data) {
        			/* TODO */
				}
				@NotNull
                public FallingBlock spawnFallingBlock(Location location, Material material, byte data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ) {
        			/* TODO */
				}
                public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data, boolean force) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data) {
        			/* TODO */
				}
                public <T> void spawnParticle(Particle particle, Location location, int count, T data) {
        			/* TODO */
				}
				@NotNull
                public World.Spigot spigot() {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightning(Location loc) {
        			/* TODO */
				}
				@NotNull
                public LightningStrike strikeLightningEffect(Location loc) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z) {
        			/* TODO */
				}
                public boolean unloadChunk(int x, int z, boolean save) {
        			/* TODO */
				}
                public boolean unloadChunk(Chunk chunk) {
        			/* TODO */
				}
                public boolean unloadChunkRequest(int x, int z) {
        			/* TODO */
				}
				@NotNull
                public NamespacedKey getKey() {
        			return key;
			}
                public NamespacedKey key;
        
				@NotNull
                public List<MetadataValue> getMetadata(String metadataKey) {
        			/* TODO */
				}
                public boolean hasMetadata(String metadataKey) {
        			/* TODO */
				}
                public void removeMetadata(String metadataKey, Plugin owningPlugin) {
        			/* TODO */
				}
                public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
        			/* TODO */
				}
				@NotNull
                public PersistentDataContainer getPersistentDataContainer() {
        			return persistentDataContainer;
			}
                public PersistentDataContainer persistentDataContainer;
        
				@NotNull
                public Set<String> getListeningPluginChannels() {
        			return listeningPluginChannels;
			}
                public Set<String> listeningPluginChannels;
        
                public void sendPluginMessage(Plugin source, String channel, byte[] message) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Predicate<BlockState> statePredicate) {
        			/* TODO */
				}
                public boolean generateTree(Location location, Random random, TreeType type, Consumer<BlockState> stateConsumer) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Biome getBiome(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockData getBlockData(Location location) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public BlockState getBlockState(Location location) {
        			/* TODO */
				}
				@NotNull
                public Material getType(int x, int y, int z) {
        			/* TODO */
				}
				@NotNull
                public Material getType(Location location) {
        			/* TODO */
				}
                public void setBiome(int x, int y, int z, Biome biome) {
        			/* TODO */
				}
                public void setBiome(Location location, Biome biome) {
        			/* TODO */
				}
                public void setBlockData(int x, int y, int z, BlockData blockData) {
        			/* TODO */
				}
                public void setBlockData(Location location, BlockData blockData) {
        			/* TODO */
				}
                public void setType(int x, int y, int z, Material material) {
        			/* TODO */
				}
                public void setType(Location location, Material material) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, boolean randomizeData, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                <T extends spawn(Location location, Class<T> clazz, Consumer<T> function) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location location, EntityType type) {
        			/* TODO */
				}
				@NotNull
                public Entity spawnEntity(Location loc, EntityType type, boolean randomizeData) {
        			/* TODO */
				}
				@NotNull
                public World.Environment getEnvironment() {
        			return environment;
			}
                public World.Environment environment;
        
                public int getMaxHeight() {
        			return maxHeight;
			}
                public int maxHeight;
        
                public int getMinHeight() {
        			return minHeight;
			}
                public int minHeight;
        
				@NotNull
                public String getName() {
        			return name;
			}
                public String name;
        
                public long getSeed() {
        			return seed;
			}
                public long seed;
        
				@NotNull
                public UUID getUID() {
        			return uID;
			}
                public UUID uID;
        
            };
            return obj;
        }
    
    }
    public void callFunction(String funcName, String[] args) {
        switch(funcName) {

            case "addRecipe":
                	/* org.bukkit.Bukkit.addRecipe(Recipe recipe, ) */
				
            break;
            
            case "advancementIterator":
                	/* org.bukkit.Bukkit.advancementIterator() */
				
            break;
            
            case "banIP":
                	/* org.bukkit.Bukkit.banIP(String address, ) */
				
            break;
            
            case "org_bukkit_Bukkit_broadcast":
                	/* org.bukkit.Bukkit.broadcast(String message, String permission, ) */
				
            break;
            
            case "broadcastMessage":
                	/* org.bukkit.Bukkit.broadcastMessage(String message, ) */
				
            break;
            
            case "clearRecipes":
                	/* org.bukkit.Bukkit.clearRecipes() */
				
            break;
            
            case "craftItem":
                	/* org.bukkit.Bukkit.craftItem(ItemStack[] craftingMatrix, World world, Player player, ) */
				
            break;
            
            case "org_bukkit_Bukkit_createBlockData":
                	/* org.bukkit.Bukkit.createBlockData(String data, ) */
					/* org.bukkit.Bukkit.createBlockData(Material material, ) */
					/* org.bukkit.Bukkit.createBlockData(Material material, String data, ) */
					/* org.bukkit.Bukkit.createBlockData(Material material, Consumer<BlockData> consumer, ) */
				
            break;
            
            case "org_bukkit_Bukkit_createBossBar":
                	/* org.bukkit.Bukkit.createBossBar(String title, BarColor color, BarStyle style, BarFlag... flags, ) */
					/* org.bukkit.Bukkit.createBossBar(NamespacedKey key, String title, BarColor color, BarStyle style, BarFlag... flags, ) */
				
            break;
            
            case "createChunkData":
                	/* org.bukkit.Bukkit.createChunkData(World world, ) */
				
            break;
            
            case "org_bukkit_Bukkit_createExplorerMap":
                	/* org.bukkit.Bukkit.createExplorerMap(World world, Location location, StructureType structureType, ) */
					/* org.bukkit.Bukkit.createExplorerMap(World world, Location location, StructureType structureType, int radius, boolean findUnexplored, ) */
				
            break;
            
            case "org_bukkit_Bukkit_createInventory":
                	/* org.bukkit.Bukkit.createInventory(InventoryHolder owner, int size, ) */
					/* org.bukkit.Bukkit.createInventory(InventoryHolder owner, int size, String title, ) */
					/* org.bukkit.Bukkit.createInventory(InventoryHolder owner, InventoryType type, ) */
					/* org.bukkit.Bukkit.createInventory(InventoryHolder owner, InventoryType type, String title, ) */
				
            break;
            
            case "createMap":
                	/* org.bukkit.Bukkit.createMap(World world, ) */
				
            break;
            
            case "createMerchant":
                	/* org.bukkit.Bukkit.createMerchant(String title, ) */
				
            break;
            
            case "org_bukkit_Bukkit_createPlayerProfile":
                	/* org.bukkit.Bukkit.createPlayerProfile(String name, ) */
					/* org.bukkit.Bukkit.createPlayerProfile(UUID uniqueId, ) */
					/* org.bukkit.Bukkit.createPlayerProfile(UUID uniqueId, String name, ) */
				
            break;
            
            case "org_bukkit_Bukkit_createWorld":
                	/* org.bukkit.Bukkit.createWorld(WorldCreator creator, ) */
				
            break;
            
            case "createWorldBorder":
                	/* org.bukkit.Bukkit.createWorldBorder() */
				
            break;
            
            case "dispatchCommand":
                	/* org.bukkit.Bukkit.dispatchCommand(CommandSender sender, String commandLine, ) */
				
            break;
            
            case "getAdvancement":
                	/* org.bukkit.Bukkit.getAdvancement(NamespacedKey key, ) */
				
            break;
            
            case "getAllowEnd":
                	/* org.bukkit.Bukkit.getAllowEnd() */
				
            break;
            
            case "getAllowFlight":
                	/* org.bukkit.Bukkit.getAllowFlight() */
				
            break;
            
            case "getAllowNether":
                	/* org.bukkit.Bukkit.getAllowNether() */
				
            break;
            
            case "getAmbientSpawnLimit":
                	/* org.bukkit.Bukkit.getAmbientSpawnLimit() */
				
            break;
            
            case "getAnimalSpawnLimit":
                	/* org.bukkit.Bukkit.getAnimalSpawnLimit() */
				
            break;
            
            case "getBanList":
                	/* org.bukkit.Bukkit.getBanList(BanList.Type type, ) */
				
            break;
            
            case "getBannedPlayers":
                	/* org.bukkit.Bukkit.getBannedPlayers() */
				
            break;
            
            case "getBossBar":
                	/* org.bukkit.Bukkit.getBossBar(NamespacedKey key, ) */
				
            break;
            
            case "getBossBars":
                	/* org.bukkit.Bukkit.getBossBars() */
				
            break;
            
            case "getBukkitVersion":
                	/* org.bukkit.Bukkit.getBukkitVersion() */
				
            break;
            
            case "getCommandAliases":
                	/* org.bukkit.Bukkit.getCommandAliases() */
				
            break;
            
            case "getConnectionThrottle":
                	/* org.bukkit.Bukkit.getConnectionThrottle() */
				
            break;
            
            case "getConsoleSender":
                	/* org.bukkit.Bukkit.getConsoleSender() */
				
            break;
            
            case "getCraftingRecipe":
                	/* org.bukkit.Bukkit.getCraftingRecipe(ItemStack[] craftingMatrix, World world, ) */
				
            break;
            
            case "getDefaultGameMode":
                	/* org.bukkit.Bukkit.getDefaultGameMode() */
				
            break;
            
            case "org_bukkit_Bukkit_getEntity":
                	/* org.bukkit.Bukkit.getEntity(UUID uuid, ) */
				
            break;
            
            case "getGenerateStructures":
                	/* org.bukkit.Bukkit.getGenerateStructures() */
				
            break;
            
            case "getHelpMap":
                	/* org.bukkit.Bukkit.getHelpMap() */
				
            break;
            
            case "getHideOnlinePlayers":
                	/* org.bukkit.Bukkit.getHideOnlinePlayers() */
				
            break;
            
            case "getIdleTimeout":
                	/* org.bukkit.Bukkit.getIdleTimeout() */
				
            break;
            
            case "getIp":
                	/* org.bukkit.Bukkit.getIp() */
				
            break;
            
            case "getIPBans":
                	/* org.bukkit.Bukkit.getIPBans() */
				
            break;
            
            case "getItemFactory":
                	/* org.bukkit.Bukkit.getItemFactory() */
				
            break;
            
            case "getLogger":
                	/* org.bukkit.Bukkit.getLogger() */
				
            break;
            
            case "getLootTable":
                	/* org.bukkit.Bukkit.getLootTable(NamespacedKey key, ) */
				
            break;
            
            case "getMap":
                	/* org.bukkit.Bukkit.getMap(int id, ) */
				
            break;
            
            case "getMaxChainedNeighborUpdates":
                	/* org.bukkit.Bukkit.getMaxChainedNeighborUpdates() */
				
            break;
            
            case "getMaxPlayers":
                	/* org.bukkit.Bukkit.getMaxPlayers() */
				
            break;
            
            case "getMaxWorldSize":
                	/* org.bukkit.Bukkit.getMaxWorldSize() */
				
            break;
            
            case "getMessenger":
                	/* org.bukkit.Bukkit.getMessenger() */
				
            break;
            
            case "getMonsterSpawnLimit":
                	/* org.bukkit.Bukkit.getMonsterSpawnLimit() */
				
            break;
            
            case "getMotd":
                	/* org.bukkit.Bukkit.getMotd() */
				
            break;
            
            case "org_bukkit_Bukkit_getName":
                	/* org.bukkit.Bukkit.getName() */
				
            break;
            
            case "org_bukkit_Bukkit_getOfflinePlayer":
                	/* org.bukkit.Bukkit.getOfflinePlayer(String name, ) */
					/* org.bukkit.Bukkit.getOfflinePlayer(UUID id, ) */
				
            break;
            
            case "getOfflinePlayers":
                	/* org.bukkit.Bukkit.getOfflinePlayers() */
				
            break;
            
            case "getOnlineMode":
                	/* org.bukkit.Bukkit.getOnlineMode() */
				
            break;
            
            case "getOnlinePlayers":
                	/* org.bukkit.Bukkit.getOnlinePlayers() */
				
            break;
            
            case "getOperators":
                	/* org.bukkit.Bukkit.getOperators() */
				
            break;
            
            case "org_bukkit_Bukkit_getPlayer":
                	/* org.bukkit.Bukkit.getPlayer(String name, ) */
					/* org.bukkit.Bukkit.getPlayer(UUID id, ) */
				
            break;
            
            case "getPlayerExact":
                	/* org.bukkit.Bukkit.getPlayerExact(String name, ) */
				
            break;
            
            case "getPluginCommand":
                	/* org.bukkit.Bukkit.getPluginCommand(String name, ) */
				
            break;
            
            case "getPluginManager":
                	/* org.bukkit.Bukkit.getPluginManager() */
				
            break;
            
            case "getPort":
                	/* org.bukkit.Bukkit.getPort() */
				
            break;
            
            case "getRecipe":
                	/* org.bukkit.Bukkit.getRecipe(NamespacedKey recipeKey, ) */
				
            break;
            
            case "getRecipesFor":
                	/* org.bukkit.Bukkit.getRecipesFor(ItemStack result, ) */
				
            break;
            
            case "getRegistry":
                	/* org.bukkit.Bukkit.getRegistry(Class<T> tClass, ) */
				
            break;
            
            case "getResourcePack":
                	/* org.bukkit.Bukkit.getResourcePack() */
				
            break;
            
            case "getResourcePackHash":
                	/* org.bukkit.Bukkit.getResourcePackHash() */
				
            break;
            
            case "getResourcePackPrompt":
                	/* org.bukkit.Bukkit.getResourcePackPrompt() */
				
            break;
            
            case "getScheduler":
                	/* org.bukkit.Bukkit.getScheduler() */
				
            break;
            
            case "getScoreboardCriteria":
                	/* org.bukkit.Bukkit.getScoreboardCriteria(String name, ) */
				
            break;
            
            case "getScoreboardManager":
                	/* org.bukkit.Bukkit.getScoreboardManager() */
				
            break;
            
            case "getServer":
                	/* org.bukkit.Bukkit.getServer() */
				
            break;
            
            case "getServerIcon":
                	/* org.bukkit.Bukkit.getServerIcon() */
				
            break;
            
            case "getServicesManager":
                	/* org.bukkit.Bukkit.getServicesManager() */
				
            break;
            
            case "getShutdownMessage":
                	/* org.bukkit.Bukkit.getShutdownMessage() */
				
            break;
            
            case "getSimulationDistance":
                	/* org.bukkit.Bukkit.getSimulationDistance() */
				
            break;
            
            case "getSpawnLimit":
                	/* org.bukkit.Bukkit.getSpawnLimit(SpawnCategory spawnCategory, ) */
				
            break;
            
            case "getSpawnRadius":
                	/* org.bukkit.Bukkit.getSpawnRadius() */
				
            break;
            
            case "getStructureManager":
                	/* org.bukkit.Bukkit.getStructureManager() */
				
            break;
            
            case "getTag":
                	/* org.bukkit.Bukkit.getTag(String registry, NamespacedKey tag, Class<T> clazz, ) */
				
            break;
            
            case "getTags":
                	/* org.bukkit.Bukkit.getTags(String registry, Class<T> clazz, ) */
				
            break;
            
            case "getTicksPerAmbientSpawns":
                	/* org.bukkit.Bukkit.getTicksPerAmbientSpawns() */
				
            break;
            
            case "getTicksPerAnimalSpawns":
                	/* org.bukkit.Bukkit.getTicksPerAnimalSpawns() */
				
            break;
            
            case "getTicksPerMonsterSpawns":
                	/* org.bukkit.Bukkit.getTicksPerMonsterSpawns() */
				
            break;
            
            case "getTicksPerSpawns":
                	/* org.bukkit.Bukkit.getTicksPerSpawns(SpawnCategory spawnCategory, ) */
				
            break;
            
            case "getTicksPerWaterAmbientSpawns":
                	/* org.bukkit.Bukkit.getTicksPerWaterAmbientSpawns() */
				
            break;
            
            case "getTicksPerWaterSpawns":
                	/* org.bukkit.Bukkit.getTicksPerWaterSpawns() */
				
            break;
            
            case "getTicksPerWaterUndergroundCreatureSpawns":
                	/* org.bukkit.Bukkit.getTicksPerWaterUndergroundCreatureSpawns() */
				
            break;
            
            case "getUnsafe":
                	/* org.bukkit.Bukkit.getUnsafe() */
				
            break;
            
            case "getUpdateFolder":
                	/* org.bukkit.Bukkit.getUpdateFolder() */
				
            break;
            
            case "getUpdateFolderFile":
                	/* org.bukkit.Bukkit.getUpdateFolderFile() */
				
            break;
            
            case "getVersion":
                	/* org.bukkit.Bukkit.getVersion() */
				
            break;
            
            case "getViewDistance":
                	/* org.bukkit.Bukkit.getViewDistance() */
				
            break;
            
            case "getWarningState":
                	/* org.bukkit.Bukkit.getWarningState() */
				
            break;
            
            case "getWaterAmbientSpawnLimit":
                	/* org.bukkit.Bukkit.getWaterAmbientSpawnLimit() */
				
            break;
            
            case "getWaterAnimalSpawnLimit":
                	/* org.bukkit.Bukkit.getWaterAnimalSpawnLimit() */
				
            break;
            
            case "getWaterUndergroundCreatureSpawnLimit":
                	/* org.bukkit.Bukkit.getWaterUndergroundCreatureSpawnLimit() */
				
            break;
            
            case "getWhitelistedPlayers":
                	/* org.bukkit.Bukkit.getWhitelistedPlayers() */
				
            break;
            
            case "org_bukkit_Bukkit_getWorld":
                	/* org.bukkit.Bukkit.getWorld(String name, ) */
					/* org.bukkit.Bukkit.getWorld(UUID uid, ) */
				
            break;
            
            case "getWorldContainer":
                	/* org.bukkit.Bukkit.getWorldContainer() */
				
            break;
            
            case "getWorlds":
                	/* org.bukkit.Bukkit.getWorlds() */
				
            break;
            
            case "getWorldType":
                	/* org.bukkit.Bukkit.getWorldType() */
				
            break;
            
            case "hasWhitelist":
                	/* org.bukkit.Bukkit.hasWhitelist() */
				
            break;
            
            case "isEnforcingSecureProfiles":
                	/* org.bukkit.Bukkit.isEnforcingSecureProfiles() */
				
            break;
            
            case "isHardcore":
                	/* org.bukkit.Bukkit.isHardcore() */
				
            break;
            
            case "isPrimaryThread":
                	/* org.bukkit.Bukkit.isPrimaryThread() */
				
            break;
            
            case "isResourcePackRequired":
                	/* org.bukkit.Bukkit.isResourcePackRequired() */
				
            break;
            
            case "isWhitelistEnforced":
                	/* org.bukkit.Bukkit.isWhitelistEnforced() */
				
            break;
            
            case "org_bukkit_Bukkit_loadServerIcon":
                	/* org.bukkit.Bukkit.loadServerIcon(BufferedImage image, ) */
					/* org.bukkit.Bukkit.loadServerIcon(File file, ) */
				
            break;
            
            case "matchPlayer":
                	/* org.bukkit.Bukkit.matchPlayer(String name, ) */
				
            break;
            
            case "recipeIterator":
                	/* org.bukkit.Bukkit.recipeIterator() */
				
            break;
            
            case "reload":
                	/* org.bukkit.Bukkit.reload() */
				
            break;
            
            case "reloadData":
                	/* org.bukkit.Bukkit.reloadData() */
				
            break;
            
            case "reloadWhitelist":
                	/* org.bukkit.Bukkit.reloadWhitelist() */
				
            break;
            
            case "removeBossBar":
                	/* org.bukkit.Bukkit.removeBossBar(NamespacedKey key, ) */
				
            break;
            
            case "removeRecipe":
                	/* org.bukkit.Bukkit.removeRecipe(NamespacedKey key, ) */
				
            break;
            
            case "resetRecipes":
                	/* org.bukkit.Bukkit.resetRecipes() */
				
            break;
            
            case "savePlayers":
                	/* org.bukkit.Bukkit.savePlayers() */
				
            break;
            
            case "selectEntities":
                	/* org.bukkit.Bukkit.selectEntities(CommandSender sender, String selector, ) */
				
            break;
            
            case "setDefaultGameMode":
                	/* org.bukkit.Bukkit.setDefaultGameMode(GameMode mode, ) */
				
            break;
            
            case "setIdleTimeout":
                	/* org.bukkit.Bukkit.setIdleTimeout(int threshold, ) */
				
            break;
            
            case "setServer":
                	/* org.bukkit.Bukkit.setServer(Server server, ) */
				
            break;
            
            case "setSpawnRadius":
                	/* org.bukkit.Bukkit.setSpawnRadius(int value, ) */
				
            break;
            
            case "setWhitelist":
                	/* org.bukkit.Bukkit.setWhitelist(boolean value, ) */
				
            break;
            
            case "setWhitelistEnforced":
                	/* org.bukkit.Bukkit.setWhitelistEnforced(boolean value, ) */
				
            break;
            
            case "shouldSendChatPreviews":
                	/* org.bukkit.Bukkit.shouldSendChatPreviews() */
				
            break;
            
            case "shutdown":
                	/* org.bukkit.Bukkit.shutdown() */
				
            break;
            
            case "spigot":
                	/* org.bukkit.Bukkit.spigot() */
				
            break;
            
            case "unbanIP":
                	/* org.bukkit.Bukkit.unbanIP(String address, ) */
				
            break;
            
            case "org_bukkit_Bukkit_unloadWorld":
                	/* org.bukkit.Bukkit.unloadWorld(String name, boolean save, ) */
					/* org.bukkit.Bukkit.unloadWorld(World world, boolean save, ) */
				
            break;
            
            case "asBGR":
                	/* org.bukkit.Color.asBGR() */
				
            break;
            
            case "asRGB":
                	/* org.bukkit.Color.asRGB() */
				
            break;
            
            case "org_bukkit_Color_deserialize":
                	/* org.bukkit.Color.deserialize(Object> map, ) */
				
            break;
            
            case "org_bukkit_Color_equals":
                	/* org.bukkit.Color.equals(Object o, ) */
				
            break;
            
            case "org_bukkit_Color_fromBGR":
                	/* org.bukkit.Color.fromBGR(int bgr, ) */
					/* org.bukkit.Color.fromBGR(int blue, int green, int red, ) */
				
            break;
            
            case "org_bukkit_Color_fromRGB":
                	/* org.bukkit.Color.fromRGB(int rgb, ) */
					/* org.bukkit.Color.fromRGB(int red, int green, int blue, ) */
				
            break;
            
            case "getBlue":
                	/* org.bukkit.Color.getBlue() */
				
            break;
            
            case "getGreen":
                	/* org.bukkit.Color.getGreen() */
				
            break;
            
            case "getRed":
                	/* org.bukkit.Color.getRed() */
				
            break;
            
            case "org_bukkit_Color_hashCode":
                	/* org.bukkit.Color.hashCode() */
				
            break;
            
            case "mixColors":
                	/* org.bukkit.Color.mixColors(Color... colors, ) */
				
            break;
            
            case "mixDyes":
                	/* org.bukkit.Color.mixDyes(DyeColor... colors, ) */
				
            break;
            
            case "org_bukkit_Color_serialize":
                	/* org.bukkit.Color.serialize() */
				
            break;
            
            case "setBlue":
                	/* org.bukkit.Color.setBlue(int blue, ) */
				
            break;
            
            case "setGreen":
                	/* org.bukkit.Color.setGreen(int green, ) */
				
            break;
            
            case "setRed":
                	/* org.bukkit.Color.setRed(int red, ) */
				
            break;
            
            case "org_bukkit_Color_toString":
                	/* org.bukkit.Color.toString() */
				
            break;
            
            case "builder":
                	/* org.bukkit.FireworkEffect.builder() */
				
            break;
            
            case "org_bukkit_FireworkEffect_deserialize":
                	/* org.bukkit.FireworkEffect.deserialize(Object> map, ) */
				
            break;
            
            case "org_bukkit_FireworkEffect_equals":
                	/* org.bukkit.FireworkEffect.equals(Object obj, ) */
				
            break;
            
            case "getColors":
                	/* org.bukkit.FireworkEffect.getColors() */
				
            break;
            
            case "getFadeColors":
                	/* org.bukkit.FireworkEffect.getFadeColors() */
				
            break;
            
            case "org_bukkit_FireworkEffect_getType":
                	/* org.bukkit.FireworkEffect.getType() */
				
            break;
            
            case "hasFlicker":
                	/* org.bukkit.FireworkEffect.hasFlicker() */
				
            break;
            
            case "org_bukkit_FireworkEffect_hashCode":
                	/* org.bukkit.FireworkEffect.hashCode() */
				
            break;
            
            case "hasTrail":
                	/* org.bukkit.FireworkEffect.hasTrail() */
				
            break;
            
            case "org_bukkit_FireworkEffect_serialize":
                	/* org.bukkit.FireworkEffect.serialize() */
				
            break;
            
            case "org_bukkit_FireworkEffect_toString":
                	/* org.bukkit.FireworkEffect.toString() */
				
            break;
            
            case "build":
                	/* org.bukkit.FireworkEffect.Builder.build() */
				
            break;
            
            case "flicker":
                	/* org.bukkit.FireworkEffect.Builder.flicker(boolean flicker, ) */
				
            break;
            
            case "trail":
                	/* org.bukkit.FireworkEffect.Builder.trail(boolean trail, ) */
				
            break;
            
            case "with":
                	/* org.bukkit.FireworkEffect.Builder.with(FireworkEffect.Type type, ) */
				
            break;
            
            case "org_bukkit_FireworkEffect_Builder_withColor":
                	/* org.bukkit.FireworkEffect.Builder.withColor(Iterable<?> colors, ) */
					/* org.bukkit.FireworkEffect.Builder.withColor(Color color, ) */
					/* org.bukkit.FireworkEffect.Builder.withColor(Color... colors, ) */
				
            break;
            
            case "org_bukkit_FireworkEffect_Builder_withFade":
                	/* org.bukkit.FireworkEffect.Builder.withFade(Iterable<?> colors, ) */
					/* org.bukkit.FireworkEffect.Builder.withFade(Color color, ) */
					/* org.bukkit.FireworkEffect.Builder.withFade(Color... colors, ) */
				
            break;
            
            case "withFlicker":
                	/* org.bukkit.FireworkEffect.Builder.withFlicker() */
				
            break;
            
            case "withTrail":
                	/* org.bukkit.FireworkEffect.Builder.withTrail() */
				
            break;
            
            case "getByKey":
                	/* org.bukkit.GameEvent.getByKey(NamespacedKey namespacedKey, ) */
				
            break;
            
            case "org_bukkit_GameEvent_getKey":
                	/* org.bukkit.GameEvent.getKey() */
				
            break;
            
            case "org_bukkit_GameEvent_values":
                	/* org.bukkit.GameEvent.values() */
				
            break;
            
            case "org_bukkit_GameRule_equals":
                	/* org.bukkit.GameRule.equals(Object obj, ) */
				
            break;
            
            case "getByName":
                	/* org.bukkit.GameRule.getByName(String rule, ) */
				
            break;
            
            case "org_bukkit_GameRule_getName":
                	/* org.bukkit.GameRule.getName() */
				
            break;
            
            case "org_bukkit_GameRule_getType":
                	/* org.bukkit.GameRule.getType() */
				
            break;
            
            case "org_bukkit_GameRule_toString":
                	/* org.bukkit.GameRule.toString() */
				
            break;
            
            case "org_bukkit_GameRule_values":
                	/* org.bukkit.GameRule.values() */
				
            break;
            
            case "org_bukkit_Location_add":
                	/* org.bukkit.Location.add(double x, double y, double z, ) */
					/* org.bukkit.Location.add(Location vec, ) */
					/* org.bukkit.Location.add(Vector vec, ) */
				
            break;
            
            case "checkFinite":
                	/* org.bukkit.Location.checkFinite() */
				
            break;
            
            case "clone":
                	/* org.bukkit.Location.clone() */
				
            break;
            
            case "org_bukkit_Location_deserialize":
                	/* org.bukkit.Location.deserialize(Object> args, ) */
				
            break;
            
            case "distance":
                	/* org.bukkit.Location.distance(Location o, ) */
				
            break;
            
            case "distanceSquared":
                	/* org.bukkit.Location.distanceSquared(Location o, ) */
				
            break;
            
            case "org_bukkit_Location_equals":
                	/* org.bukkit.Location.equals(Object obj, ) */
				
            break;
            
            case "org_bukkit_Location_getBlock":
                	/* org.bukkit.Location.getBlock() */
				
            break;
            
            case "getBlockX":
                	/* org.bukkit.Location.getBlockX() */
				
            break;
            
            case "getBlockY":
                	/* org.bukkit.Location.getBlockY() */
				
            break;
            
            case "getBlockZ":
                	/* org.bukkit.Location.getBlockZ() */
				
            break;
            
            case "getChunk":
                	/* org.bukkit.Location.getChunk() */
				
            break;
            
            case "getDirection":
                	/* org.bukkit.Location.getDirection() */
				
            break;
            
            case "getPitch":
                	/* org.bukkit.Location.getPitch() */
				
            break;
            
            case "org_bukkit_Location_getWorld":
                	/* org.bukkit.Location.getWorld() */
				
            break;
            
            case "getX":
                	/* org.bukkit.Location.getX() */
				
            break;
            
            case "getY":
                	/* org.bukkit.Location.getY() */
				
            break;
            
            case "getYaw":
                	/* org.bukkit.Location.getYaw() */
				
            break;
            
            case "getZ":
                	/* org.bukkit.Location.getZ() */
				
            break;
            
            case "org_bukkit_Location_hashCode":
                	/* org.bukkit.Location.hashCode() */
				
            break;
            
            case "isWorldLoaded":
                	/* org.bukkit.Location.isWorldLoaded() */
				
            break;
            
            case "length":
                	/* org.bukkit.Location.length() */
				
            break;
            
            case "lengthSquared":
                	/* org.bukkit.Location.lengthSquared() */
				
            break;
            
            case "locToBlock":
                	/* org.bukkit.Location.locToBlock(double loc, ) */
				
            break;
            
            case "multiply":
                	/* org.bukkit.Location.multiply(double m, ) */
				
            break;
            
            case "normalizePitch":
                	/* org.bukkit.Location.normalizePitch(float pitch, ) */
				
            break;
            
            case "normalizeYaw":
                	/* org.bukkit.Location.normalizeYaw(float yaw, ) */
				
            break;
            
            case "org_bukkit_Location_serialize":
                	/* org.bukkit.Location.serialize() */
				
            break;
            
            case "setDirection":
                	/* org.bukkit.Location.setDirection(Vector vector, ) */
				
            break;
            
            case "setPitch":
                	/* org.bukkit.Location.setPitch(float pitch, ) */
				
            break;
            
            case "setWorld":
                	/* org.bukkit.Location.setWorld(World world, ) */
				
            break;
            
            case "setX":
                	/* org.bukkit.Location.setX(double x, ) */
				
            break;
            
            case "setY":
                	/* org.bukkit.Location.setY(double y, ) */
				
            break;
            
            case "setYaw":
                	/* org.bukkit.Location.setYaw(float yaw, ) */
				
            break;
            
            case "setZ":
                	/* org.bukkit.Location.setZ(double z, ) */
				
            break;
            
            case "org_bukkit_Location_subtract":
                	/* org.bukkit.Location.subtract(double x, double y, double z, ) */
					/* org.bukkit.Location.subtract(Location vec, ) */
					/* org.bukkit.Location.subtract(Vector vec, ) */
				
            break;
            
            case "org_bukkit_Location_toString":
                	/* org.bukkit.Location.toString() */
				
            break;
            
            case "toVector":
                	/* org.bukkit.Location.toVector() */
				
            break;
            
            case "zero":
                	/* org.bukkit.Location.zero() */
				
            break;
            
            case "org_bukkit_NamespacedKey_equals":
                	/* org.bukkit.NamespacedKey.equals(Object obj, ) */
				
            break;
            
            case "org_bukkit_NamespacedKey_fromString":
                	/* org.bukkit.NamespacedKey.fromString(String key, ) */
					/* org.bukkit.NamespacedKey.fromString(String string, Plugin defaultNamespace, ) */
				
            break;
            
            case "org_bukkit_NamespacedKey_getKey":
                	/* org.bukkit.NamespacedKey.getKey() */
				
            break;
            
            case "getNamespace":
                	/* org.bukkit.NamespacedKey.getNamespace() */
				
            break;
            
            case "org_bukkit_NamespacedKey_hashCode":
                	/* org.bukkit.NamespacedKey.hashCode() */
				
            break;
            
            case "minecraft":
                	/* org.bukkit.NamespacedKey.minecraft(String key, ) */
				
            break;
            
            case "randomKey":
                	/* org.bukkit.NamespacedKey.randomKey() */
				
            break;
            
            case "org_bukkit_NamespacedKey_toString":
                	/* org.bukkit.NamespacedKey.toString() */
				
            break;
            
            case "org_bukkit_Note_equals":
                	/* org.bukkit.Note.equals(Object obj, ) */
				
            break;
            
            case "flat":
                	/* org.bukkit.Note.flat(int octave, Note.Tone tone, ) */
				
            break;
            
            case "flattened":
                	/* org.bukkit.Note.flattened() */
				
            break;
            
            case "getId":
                	/* org.bukkit.Note.getId() */
				
            break;
            
            case "getOctave":
                	/* org.bukkit.Note.getOctave() */
				
            break;
            
            case "getTone":
                	/* org.bukkit.Note.getTone() */
				
            break;
            
            case "org_bukkit_Note_hashCode":
                	/* org.bukkit.Note.hashCode() */
				
            break;
            
            case "isSharped":
                	/* org.bukkit.Note.isSharped() */
				
            break;
            
            case "natural":
                	/* org.bukkit.Note.natural(int octave, Note.Tone tone, ) */
				
            break;
            
            case "sharp":
                	/* org.bukkit.Note.sharp(int octave, Note.Tone tone, ) */
				
            break;
            
            case "sharped":
                	/* org.bukkit.Note.sharped() */
				
            break;
            
            case "org_bukkit_Note_toString":
                	/* org.bukkit.Note.toString() */
				
            break;
            
            case "getColor":
                	/* org.bukkit.Particle.DustOptions.getColor() */
				
            break;
            
            case "getSize":
                	/* org.bukkit.Particle.DustOptions.getSize() */
				
            break;
            
            case "getToColor":
                	/* org.bukkit.Particle.DustTransition.getToColor() */
				
            break;
            
            case "get":
                	/* org.bukkit.Registry.SimpleRegistry.get(NamespacedKey key, ) */
				
            break;
            
            case "iterator":
                	/* org.bukkit.Registry.SimpleRegistry.iterator() */
				
            break;
            
            case "org_bukkit_Server_Spigot_broadcast":
                	/* org.bukkit.Server.Spigot.broadcast(BaseComponent component, ) */
					/* org.bukkit.Server.Spigot.broadcast(BaseComponent... components, ) */
				
            break;
            
            case "getConfig":
                	/* org.bukkit.Server.Spigot.getConfig() */
				
            break;
            
            case "restart":
                	/* org.bukkit.Server.Spigot.restart() */
				
            break;
            
            case "org_bukkit_StructureType_equals":
                	/* org.bukkit.StructureType.equals(Object other, ) */
				
            break;
            
            case "org_bukkit_StructureType_getKey":
                	/* org.bukkit.StructureType.getKey() */
				
            break;
            
            case "getMapIcon":
                	/* org.bukkit.StructureType.getMapIcon() */
				
            break;
            
            case "org_bukkit_StructureType_getName":
                	/* org.bukkit.StructureType.getName() */
				
            break;
            
            case "getStructureTypes":
                	/* org.bukkit.StructureType.getStructureTypes() */
				
            break;
            
            case "org_bukkit_StructureType_hashCode":
                	/* org.bukkit.StructureType.hashCode() */
				
            break;
            
            case "org_bukkit_StructureType_toString":
                	/* org.bukkit.StructureType.toString() */
				
            break;
            
            case "getArrivalTime":
                	/* org.bukkit.Vibration.getArrivalTime() */
				
            break;
            
            case "getDestination":
                	/* org.bukkit.Vibration.getDestination() */
				
            break;
            
            case "getOrigin":
                	/* org.bukkit.Vibration.getOrigin() */
				
            break;
            
            case "org_bukkit_Vibration_Destination_BlockDestination_getBlock":
                	/* org.bukkit.Vibration.Destination.BlockDestination.getBlock() */
				
            break;
            
            case "getLocation":
                	/* org.bukkit.Vibration.Destination.BlockDestination.getLocation() */
				
            break;
            
            case "org_bukkit_Vibration_Destination_EntityDestination_getEntity":
                	/* org.bukkit.Vibration.Destination.EntityDestination.getEntity() */
				
            break;
            
            case "strikeLightning":
                	/* org.bukkit.World.Spigot.strikeLightning(Location loc, boolean isSilent, ) */
				
            break;
            
            case "strikeLightningEffect":
                	/* org.bukkit.World.Spigot.strikeLightningEffect(Location loc, boolean isSilent, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_biomeProvider":
                	/* org.bukkit.WorldCreator.biomeProvider() */
					/* org.bukkit.WorldCreator.biomeProvider(String biomeProvider, ) */
					/* org.bukkit.WorldCreator.biomeProvider(String biomeProvider, CommandSender output, ) */
					/* org.bukkit.WorldCreator.biomeProvider(BiomeProvider biomeProvider, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_copy":
                	/* org.bukkit.WorldCreator.copy(World world, ) */
					/* org.bukkit.WorldCreator.copy(WorldCreator creator, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_createWorld":
                	/* org.bukkit.WorldCreator.createWorld() */
				
            break;
            
            case "org_bukkit_WorldCreator_environment":
                	/* org.bukkit.WorldCreator.environment() */
					/* org.bukkit.WorldCreator.environment(World.Environment env, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_generateStructures":
                	/* org.bukkit.WorldCreator.generateStructures() */
					/* org.bukkit.WorldCreator.generateStructures(boolean generate, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_generator":
                	/* org.bukkit.WorldCreator.generator() */
					/* org.bukkit.WorldCreator.generator(String generator, ) */
					/* org.bukkit.WorldCreator.generator(String generator, CommandSender output, ) */
					/* org.bukkit.WorldCreator.generator(ChunkGenerator generator, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_generatorSettings":
                	/* org.bukkit.WorldCreator.generatorSettings() */
					/* org.bukkit.WorldCreator.generatorSettings(String generatorSettings, ) */
				
            break;
            
            case "getBiomeProviderForName":
                	/* org.bukkit.WorldCreator.getBiomeProviderForName(String world, String name, CommandSender output, ) */
				
            break;
            
            case "getGeneratorForName":
                	/* org.bukkit.WorldCreator.getGeneratorForName(String world, String name, CommandSender output, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_hardcore":
                	/* org.bukkit.WorldCreator.hardcore() */
					/* org.bukkit.WorldCreator.hardcore(boolean hardcore, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_name":
                	/* org.bukkit.WorldCreator.name() */
					/* org.bukkit.WorldCreator.name(String name, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_seed":
                	/* org.bukkit.WorldCreator.seed() */
					/* org.bukkit.WorldCreator.seed(long seed, ) */
				
            break;
            
            case "org_bukkit_WorldCreator_type":
                	/* org.bukkit.WorldCreator.type() */
					/* org.bukkit.WorldCreator.type(WorldType type, ) */
				
    }

}
