from os.path import exists
import gen_json, json, re

def get_indexes(search, arr):
    return [value for (value, key) in zip(arr, range(len(arr))) if search == value]

def first_capital(arr):
    try:
        return arr.index([value for (value, key) in zip(arr, range(len(arr))) if value[0].isupper()][0])+1
    except ValueError:
        return len(arr)

def list_to_arr(list):
    t = []
    for key, value in list.items():
        t.append(value)
        t.append(key)
    return t

# If there's no unsafe_lib.json, create it. Otherwise, load it.
unsafe_lib_body = ""
if(exists("./unsafe_lib.json")):
    print("unsafe_lib.json found, opening")
    f = open("./unsafe_lib.json", "r")
    unsafe_lib_body = f.read()
    f.close()
else:
    print("unsafe_lib.json not found, creating")
    print("parsing the main package tree")
    doc = gen_json.parse_javadoc("https://hub.spigotmc.org/javadocs/spigot/org/bukkit/package-tree.html")

    unsafe_lib_body = doc.toJSON().replace("\n","",99999999)
    f = open("unsafe_lib.json", "w")
    f.write(unsafe_lib_body)
    f.close()

unsafe_lib = json.loads(unsafe_lib_body)

f = open("../src/main/java/net/ioixd/paprika/UnsafeLibrary.java", "w")
f.truncate()

f.write("""
/*
    This file is generated by a Python script. Do not make direct modifications to it.
    Please modify the script that generates it instead.
*/
package net.ioixd.paprika;
import javax.annotation.Nullable;
import org.jetbrains.annotations.NotNull;

""")

imported = []
for i in unsafe_lib["classes"] + unsafe_lib["interfaces"]:
    name_parts = i["name"].split(".")
    # we only want the parts up until the last capital
    lc = first_capital(name_parts)
    name = ".".join(name_parts[slice(0,lc-1)])+".*"
    # no duplicates
    if name not in imported:
        f.write("import {name};\n".format(name=name))
    imported.append(name)


f.write("""
public class UnsafeLibrary {
""")

# object construction map

world_interface = None
server_interface = None
#player_interface = None

# first we want to pick out the world, server, and player interfaces for later.
for i in unsafe_lib["interfaces"]:
    name_parts = i["name"].split(".")
    name_raw = name_parts[len(name_parts)-1]
    if(name_raw == "World"):
        world_interface = i

    if(name_raw == "Server"):
        server_interface = i

    if world_interface is not None and server_interface is not None:
        break

if world_interface is None:
    raise Exception("World interface not found")
if server_interface is None:
    raise Exception("Server interface not found")
#if player_interface is None:
#    raise Exception("Player interface not found")

already_in = []

for i in unsafe_lib["interfaces"]:
    name_parts = i["name"].split(".")
    name_raw = name_parts[len(name_parts)-1]

    print("adding "+name_raw)
    if name_raw in already_in:
        print("already in")
        continue

    # the tricky thing is that "abstract methods can't be instated".

    # so before anything else, we want to exclude some objects.
    # we want to exclude world, server, and player...
    if(name_raw == "World" or name_raw == "Server" or name_raw == "Player"):
        continue

    skip = False
    # and we want to exclude objects that can be obtained via those,
    # as well as any that are "subinterfaces" of them.

    for m in world_interface["methods"]:
        mname_parts = m["name"].split(".")
        mname_raw = mname_parts[len(mname_parts)-1]
        if mname_raw == "get"+name_raw:
            print("skipping "+name_raw)
            skip = True
            break
    for inter in world_interface["superinterfaces"]:
        if inter == name_raw:
            print("skipping "+name_raw)
            skip = True
            break

    if(skip):
        continue

    for m in server_interface["methods"]:
        mname_parts = m["name"].split(".")
        mname_raw = mname_parts[len(mname_parts)-1]
        if mname_raw == "get"+name_raw:
            print("skipping "+name_raw)
            skip = True
            break

    for inter in server_interface["superinterfaces"]:
        if inter == name_raw:
            print("skipping "+name_raw)
            skip = True
            break

    if(skip):
        continue

    has_set: bool = False
    buf: str = ""

    # for the rest of the functions we have to return anonymous, non-abstract objects that implement
    # the abstract ones.

    buf += """
        {name} construct{nameraw}(String json) {{
            {nameraw} obj = new {nameraw}() {{
            """.format(name=i["name"],
                        nameraw=name_raw,
            )

    # get the interfaces that correspond to its "subinterfaces", if any
    submethods = []
    for i2 in unsafe_lib["interfaces"]:
        name_parts = i2["name"].split(".")
        name_raw = name_parts[len(name_parts)-1]
        if name_raw in i["superinterfaces"]:
            for method in i2["methods"]:
                submethods.append(method)

    added_methods = []
    added_variables = []

    # make an anonymous class that implements all of these methods.
    for m in (i["methods"] + submethods):
        # skip duplicates
        if (m["name"], m["args"]) in added_methods:
            continue

        added_methods.append((m["name"], m["args"]))

        #print(list_to_arr(m["args"]))
        args = " ".join(list_to_arr(m["args"]))
        args = re.sub('(\s[^\s]*)\s', r'\1, ', args)

        # for some methods, make sure we specify the relevant variable above.
        name = m["name"]

        if(m["nullable"] == "false"):
            buf += "\n\t\t\t\t@NotNull"
        if(m["nullable"] == "true"):
            buf += "\n\t\t\t\t@Nullable"
        if(m["nullable"] == "None"):
            buf += "\n\t\t\t\t@Override"

        buf += """
                {mod} {ty} {name}({args}) {{
        """.format(mod=m["modifier"],ty=m["ty"],name=name,args=args)

        # what we want to do now depends on the type of method.

        # for getter/setter methods, make sure the variable exists.
        get = (name.startswith("get") or name.startswith("has") or name.startswith("is"))
        set = (name.startswith("set"))
        if(get or set):
            name_stripped: str = name.replace("get","",1).replace("set","",1)
            if(name.startswith("has")):
                name_stripped = name_stripped.replace("has","",1)
            if(name.startswith("is")):
                name_stripped = name_stripped.replace("is","",1)
            if(name_stripped == ""):
                continue
            # lower case
            name_stripped = name_stripped[0].lower() + name_stripped[1:]

        if(set):
            has_set = True
            # one argument means its a simple assignment.
            items = m["args"].items()
            if(len(items) == 1):
                key = list(m["args"].keys())[0]
                value = list(m["args"].values())[0]
                buf += "\t\t\tthis.{name} = {value};".format(name=name_stripped,value=key)
                buf += """
                }
                """
                if(name_stripped in added_variables):
                    continue
                buf += """
                {mod} {ty} {name};
            """.format(mod=m["modifier"],ty=value,value=key,name=name_stripped)
                added_variables.append(name_stripped)
                continue
            # multiple arguments is a weird case that needs to be investigated.

        if(get):
            # no argument means its a simple return.
            items = m["args"].items()
            if(len(items) == 0):
                buf += "\t\t\treturn {name};\n\t\t\t\t}}".format(name=name_stripped)
                if(name_stripped in added_variables):
                    continue
                buf += """
                {mod} {ty} {name};
        """.format(mod=m["modifier"],ty=m["ty"],name=name_stripped)
                added_variables.append(name_stripped)
                continue
            # multiple arguments is a weird case that needs to be investigated.

        # if we're at this point, we've reached an exception to the naming rule. do nothing.
        buf += "\t\t\t/* TODO */\n\t\t\t\t}"

        """
            TODO:
                - begrudgingly implement a "patches" system for methods that aren't generic.
                - generic "serialize" method
                - "add___"; construct the return object using the arguments given and add it to the relevant set in the function.
                -

        """

    # TODO: object modification via the provided json

    buf += """
            };
            return obj;
        }
    """

    # if we didn't get any setter method from that, there's nothing we can
    # get from this method. skip it.
    if(has_set):
        f.write(buf)
        already_in.append(name_raw)

f.write("""
    }
    public void callFunction(World world, Server server, Player player, String funcName, String[] args) {
        switch(funcName) {
""")

# function call map

first = 0
last = ""
classnames = []
names = []

# collect the class and method names into a simple array before continuing
for c in unsafe_lib["classes"]:
    class_name = c["name"].replace(".","_")
    # collect the method names before doing anything
    for m in c["methods"]:
        # if we encounter a duplicate...
        if(m["name"] in names):
            # ...only work with it if its not a duplicate within the same class
            if(c["name"] not in classnames):
                names.append(m["name"])
        else:
            names.append(m["name"])

for c in unsafe_lib["classes"]:
    class_name = c["name"].replace(".","_")
    for m in c["methods"]:
        if first != 0 and m["name"] != last:
            f.write("""
            break;
            """)

        # are there multiple instances?
        indexes = len(get_indexes(m["name"], names))

        # if not, write it plainly.
        if(indexes == 1):
            if m["name"] != last:
                f.write("""
            case \""""+m["name"]+"""\":
                """)
        # otherwise, write it withe the class name in front of it to distinquish it.
        else:
            if m["name"] != last:
                f.write("""
            case \""""+class_name+"_"+m["name"]+"""\":
                """)

        f.write("\t/* "+c["name"]+"."+m["name"]+"(")
        for key, value in m["args"].items():
            f.write(value+" "+key+", ")
        f.write(") */\n\t\t\t\t")

        last = m["name"]
        first = 1

    classnames.append(c["name"])
# function map

f.write("""
    }
""")

f.write("""
}
""")

f.close()