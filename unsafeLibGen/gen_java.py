from os.path import exists
import gen_json, json, re

def get_indexes(search, arr):
    return [value for (value, key) in zip(arr, range(len(arr))) if search == value]

def first_capital(arr):
    try:
        return arr.index([value for (value, key) in zip(arr, range(len(arr))) if value[0].isupper()][0])+1
    except ValueError:
        return len(arr)

def list_to_arr(list):
    t = []
    for key, value in list.items():
        t.append(value)
        t.append(key)
    return t

# If there's no unsafe_lib.json, create it. Otherwise, load it.
unsafe_lib_body = ""
if(exists("./unsafe_lib.json")):
    print("unsafe_lib.json found, opening")
    f = open("./unsafe_lib.json", "r")
    unsafe_lib_body = f.read()
    f.close()
else:
    print("unsafe_lib.json not found, creating")
    print("parsing the main package tree")
    doc = gen_json.parse_javadoc("https://hub.spigotmc.org/javadocs/spigot/org/bukkit/package-tree.html")
    """
    print("parsing the profile package tree")
    doc2 = gen_json.parse_javadoc("https://hub.spigotmc.org/javadocs/spigot/org/bukkit/profile/package-tree.html")
    print("adding them")
    doc += doc2
    """
    unsafe_lib_body = doc.toJSON().replace("\n","",99999999)
    f = open("unsafe_lib.json", "w")
    f.write(unsafe_lib_body)
    f.close()

unsafe_lib = json.loads(unsafe_lib_body)

f = open("../src/main/java/net/ioixd/paprika/UnsafeLibrary.java", "w")
f.truncate()

f.write("""
/*
    This file is generated by a Python script. Do not make direct modifications to it.
    Please modify the script that generates it instead.
*/
package net.ioixd.paprika;
import javax.annotation.Nullable;
import org.jetbrains.annotations.NotNull;

""")

imported = []
for i in unsafe_lib["classes"] + unsafe_lib["interfaces"]:
    name_parts = i["name"].split(".")
    # we only want the parts up until the last capital
    lc = first_capital(name_parts)
    name = ".".join(name_parts[slice(0,lc-1)])+".*"
    # no duplicates
    if name not in imported:
        f.write("import {name};\n".format(name=name))
    imported.append(name)


f.write("""
public class UnsafeLibrary {
""")

# object construction map

for i in unsafe_lib["interfaces"]:
    name_parts = i["name"].split(".")
    name_raw = name_parts[len(name_parts)-1]

    # the tricky thing is that "abstract methods can't be instated".
    # so for these functions we have to return anonymous, non-abstract objects that implement
    # the abstract ones.

    f.write("""
        {name} construct{nameraw}(String json) {{
            {nameraw} obj = new {nameraw}() {{
            """.format(name=i["name"],
                        nameraw=name_raw,
            )
        )

    # get the interfaces that correspond to its "subinterfaces", if any
    submethods = []
    for i2 in unsafe_lib["interfaces"]:
        name_parts = i2["name"].split(".")
        name_raw = name_parts[len(name_parts)-1]
        if name_raw in i["superinterfaces"]:
            for method in i2["methods"]:
                submethods.append(method)

    added_methods = []
    added_variables = []

    # make an anonymous class that implements all of these methods.
    for m in (i["methods"] + submethods):
        # skip duplicates
        if (m["name"], m["args"]) in added_methods:
            continue

        added_methods.append((m["name"], m["args"]))

        #print(list_to_arr(m["args"]))
        args = " ".join(list_to_arr(m["args"]))
        args = re.sub('(\s[^\s]*)\s', r'\1, ', args)

        # for some methods, make sure we specify the relevant variable above.
        name = m["name"]

        if(m["nullable"] == "false"):
            f.write("\n\t\t\t\t@NotNull")
        if(m["nullable"] == "true"):
            f.write("\n\t\t\t\t@Nullable")
        if(m["nullable"] == "None"):
            f.write("\n\t\t\t\t@Override")

        f.write("""
                {mod} {ty} {name}({args}) {{
        """.format(mod=m["modifier"],ty=m["ty"],name=name,args=args)
        )

        # what we want to do now depends on the type of method.

        # for getter/setter methods, make sure the variable exists.
        get = (name.startswith("get") or name.startswith("has") or name.startswith("is"))
        set = (name.startswith("set"))
        if(get or set):
            name_stripped: str = name.replace("get","",1).replace("set","",1)
            if(name.startswith("has")):
                name_stripped = name_stripped.replace("has","",1)
            if(name.startswith("is")):
                name_stripped = name_stripped.replace("is","",1)
            if(name_stripped == ""):
                continue
            # lower case
            name_stripped = name_stripped[0].lower() + name_stripped[1:]

        if(set):
            # one argument means its a simple assignment.
            items = m["args"].items()
            if(len(items) == 1):
                key = list(m["args"].keys())[0]
                value = list(m["args"].values())[0]
                f.write("\t\t\t{name} = {value};".format(name=name_stripped,value=key))
                f.write("""
                }
                """)
                if(name_stripped in added_variables):
                    continue
                f.write("""
                {mod} {ty} {name};
            """.format(mod=m["modifier"],ty=value,value=key,name=name_stripped))
                added_variables.append(name_stripped)
                continue
            # multiple arguments is a weird case that needs to be investigated.

        if(get):
            # no argument means its a simple return.
            items = m["args"].items()
            if(len(items) == 0):
                f.write("\t\t\treturn {name};\n\t\t\t}}".format(name=name_stripped))
                if(name_stripped in added_variables):
                    continue
                f.write("""
                {mod} {ty} {name};
        """.format(mod=m["modifier"],ty=m["ty"],name=name_stripped))
                added_variables.append(name_stripped)
                continue
            # multiple arguments is a weird case that needs to be investigated.

        # if we're at this point, we've reached an exception to the naming rule. do nothing.
        f.write("\t\t\t/* TODO */\n\t\t\t\t}")

        """
            TODO:
                - begrudgingly implement a "patches" system for functions that aren't generic.
                -

        """

    # TODO: object modification via the provided json

    f.write("""
            };
            return obj;
        }
    """)

f.write("""
    }
    public void callFunction(String funcName, String[] args) {
        switch(funcName) {
""")

# function call map

first = 0
last = ""
classnames = []
names = []

# collect the class and method names into a simple array before continuing
for c in unsafe_lib["classes"]:
    class_name = c["name"].replace(".","_")
    # collect the method names before doing anything
    for m in c["methods"]:
        # if we encounter a duplicate...
        if(m["name"] in names):
            # ...only work with it if its not a duplicate within the same class
            if(c["name"] not in classnames):
                names.append(m["name"])
        else:
            names.append(m["name"])

for c in unsafe_lib["classes"]:
    class_name = c["name"].replace(".","_")
    for m in c["methods"]:
        if first != 0 and m["name"] != last:
            f.write("""
            break;
            """)

        # are there multiple instances?
        indexes = len(get_indexes(m["name"], names))

        # if not, write it plainly.
        if(indexes == 1):
            if m["name"] != last:
                f.write("""
            case \""""+m["name"]+"""\":
                """)
        # otherwise, write it withe the class name in front of it to distinquish it.
        else:
            if m["name"] != last:
                f.write("""
            case \""""+class_name+"_"+m["name"]+"""\":
                """)

        f.write("\t/* "+c["name"]+"."+m["name"]+"(")
        for key, value in m["args"].items():
            f.write(value+" "+key+", ")
        f.write(") */\n\t\t\t\t")

        last = m["name"]
        first = 1

    classnames.append(c["name"])
# function map

f.write("""
    }
""")

f.write("""
}
""")

f.close()